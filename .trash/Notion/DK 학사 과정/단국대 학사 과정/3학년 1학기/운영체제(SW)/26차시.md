## Ch. 19 Paging: Faster Translations (TLB)
### TLB(Translation Lookaside Buffer)
address-translation cache이다.
페이지 테이블은 메모리 위에 있어서 이를 사용하면서 추가적인 메모리 접근이 발생한다. → 성능상의 문제
이 문제를 해결하기 위해 TLB를 사용한다.
  
페이지 테이블은 메모리 사용을 발생시킨다. → 메모리 사용량 문제
  
TLB 검사했을
1. 히트
    1. offset을 더해서 바로 물리 주소 접근 → 메모리 접근 1번
2. 미스
    
    1. page table에 접근 → 정보를 꺼내오면서 TLB에 올린다.
    2. 물리 주소 접근 → 메모리 접근 2번
    
      
    
프레임 찾기 → 미스 → TLB에 올리기 → a[0] ~a[2]는 미스-히트-히트
마찬가지로 a[3] ~ a[6]는 미스-히트-히트-히트
a[7] ~ a[9] 미스-히트-히트
그러므로 히트율이 70%
  
그런데 반복을 여러번 할 수록 히트율이 99%로 수렴한다.
  
## Ch. 19.5 TLB issue: Context Switches(Optional)
### TLB
서로 다른 프로세스의 VPN 10번에 각각 다른 내용이 들어있는데 둘 다 TLB에 올라가있다고 하자
문맥교환을 할텐데 TLB에 저장된 VPN 10이 어떤 프로세스의 것인지 알 수 없다.
그래서 valid 여부를 체크한다.(현재 프로세스의 것만 TLB에서 valid하다고 체크함)
  
## Ch. 20 Paging: Smaller Tables
32비트 컴퓨터에서 가능한 주소는 2^32 즉 4GB → 주소공간이 4GB이다.
  
  
## Ch. 20.3
  
ㅔ.9의 경우는 PT가 하나인 경우다.
이제는 디렉토리, 여러 PT가 존재한다.
p.31
페이지 테이블을 나눈다.
앞의 것이 …⚠️
→ 32비트 컴퓨터
  
오른쪽 사진은 64비트 컴퓨터 → 4레벨로 관리한다.
  
### Inverted Page Table
원래는 페이지 테이블에 페이지 넘버가 인덱스로 활용된다.
주된 목표는 페이지가 어느 프레임에 있어를 확인하는 것이다.
  
인버티드는 거꾸로
페이지테이블
어떤 페이지 프레임에 어떤 페이지가 있는지 확인하기 위해 활용된다.
인버티드는 페이지 테이블의 사이즈를 줄일 수 있다.
페이지 테이블은 페이지 넘버가 인덱스이다. 버추얼 메모리가 만들어질 떄마다 다른 페이지 넘버를 사용해야한다.
반면 인버티드는 인덱스로 물리 주소를 사용한다.
물리 메모리는 하나뿐이라 인덱스가 하나만 존재한다.
인버티드는 주소 변환에도 사용할 수 있지만 비효율적이라 잘 사용하지는 않는다.
  
‘페이지 → 프레임’은 페이지 테이블의 역할
‘프레임 → 페이지’은 인버티드 페이지 테이블의 역할이다.
이 때 프레임의 수는 물리 메모리의 수로 제한되므로 페이지 테이블은 프로세스 수만큼 존재하는 반면, 인버티드 페이지 테이블은 한 개만 존재한다.
이게 페이지 테이블의 수를 줄이는데 무슨 상관이 있나 싶지만 이정도로 알고있기
잘 사용하지 않지만 결국 사용하긴 하는 인버티드 페이지 테이블의 주소 변환 역할이 존재한다는 정도 알고있으면 될 듯.
  
## Ch. 21 Beyond Physical Memory: Mechanisms
동영상으로 확인
간단 요약: 가상 메모리의 모든것이 물리 메모리에 있다고 배웠는데 실제로는 그렇지 않고 디스크상에도 좀 있다.
디스크로 내릴 때 프로세스 통쨰로 swap out, swap in가능
페이지 단위로 page out, page in가능
물리 메모리에서 디스크로 내릴 때 무엇을 내릴지 결정하는 것을 21장에서 배운다.