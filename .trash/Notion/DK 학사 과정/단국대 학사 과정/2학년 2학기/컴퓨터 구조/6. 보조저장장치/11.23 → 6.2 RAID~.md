리뷰
꼭 알아야 하는 것
예제 6-1
평균 액세스 시간 계산
헤드가 어디에 있는지 주어지고 트랙을 찾아가는데 걸리는 시간 계산
6장 연습문제 풀어보기
시험 출제
  
## 6.2 RAID
Redundant Array of Inexpensive Disks
한 개의 대형 HDD 사용은 가격이 비싸다
싸고 작은 용량을 가진 HDD를 연결해서 큰 저장장치를 만들면 장점 발생
분산 저장
병렬 데이터 채널에 의한 데이터 동시에 읽어오기
전송 속도 향상
거의 모든 서버에서 이용하는 저장 장치이다.
문제점
결함 발생 가능성 증가
HDD를 많이 사용하기 때문에 발생
MTTF(mean time to failure) 단축
  
디스크 인터리빙 방식으로 데이터 저장
인터리브는 성능을 높이기 위해 데이터가 서로 인접하지 않도록 배열하는 방법이다.
데이터를 분산해서 순서대로 저장한다.
균등 분산 저장을 위하여 라운드-로빈 방식 사용
  
대용량 HDD 와 RAID의 비교
RAID가 더 싸고 전력도 덜 든다.
하지만 MTTF가 단축된다.
MTTF = 단일 디스크의 MTTF / 배열 내 디스크들의 수
자주 발생하는 오류를 해결할 수 있는 방법 모색이 필요하다.
디스크 배열의 결함허용도를 높이기 위하여 RAID가 제안됨
  
핵심 기술
검사 디스크들을 이용하여 오류 검출 및 복구
디스크 결함 발생 시의 복구 절차
- 해당 디스크 사용 중단 & 시스템으로부터 분리
- 검사디스크에 저장된 정보로 원래 데이터 복구
- 결함 수리 후 디스크 재설치
- 시스템 재구성
  
## RAID의 종류
1. RAID-1
    
    ![[Source/Untitled 132.png|Untitled 132.png]]
    
디스크 미러링
데이터 디스크와 짝을 이루는 미러 디스크를 두고 데이터 복사
높은 신뢰도를 요구하는 결함 허용 시스템에서 주로 사용
시스템 소프트웨어 및 중요한 데이터 파일에 사용
장점
거의 완전한 결함허용도 제공
단점
가격이 높다.
1. RAID-2
    
    ![[Source/Untitled 1 86.png|Untitled 1 86.png]]
    
    비트-단위 인터리빙
    
    데이터를 각 디스크에 비트 단위로 분산 저장
    
    검사 디스크의 해밍 코드를 이용한 오류 검출 및 정정
    
    단점
    
    필요한 검사 디스크가 많아 가격이 비싸다.
    
      
    
2. RAID-3
    
    ![[Source/Untitled 2 58.png|Untitled 2 58.png]]
    
    패리티 방식
    
    패리티 방식을 이용한 오류 검출 및 정정 방식 사용
    
    정정 방식을 사용할 때 패리티 디스크가 3개 이상 필요
    
    디스크를 1개만 사용하면 오류 검출만 가능하다.
    
    XOR 연산을 사용
    
    A xor B이면 A와 B가 달라야 결과가 1이다.
    
    0101 0 에서 오류 발생해서 0001 0이 된다면
    
    b2 = 0 xor 0 xor 0 xor 1 = 1 (p xor b1 xor b3 xor b4) 이 계산에 어긋나므로 결함 확인이 가능하다.
    
    짝수 패리티를 사용하면 모든 비트를 xor했을 때 결과가 0이 나와야한다.
    
    RAID-4 방식을 더 많이 사용한다.
    
      
    
    - Parity check
        - 데이터 전송 부분에서 폭넓게 사용된다.
        - ex
            
            - 8bit 데이터를 보낸다고 하자
            - 하나의 추가 bit을 오류 체크 용으로 사용한다.(Parity bit)
            - 9개의 bit을 데이터 전송에 사용한다.
            - 01010010을 보낸다고 했을 때
                - even parity | odd parity 사용 가능
                - even parity를 많이 사용한다.
                - 원래 데이터의 1의 갯수를 카운트하면 된다.
                - 카운트 후 1의 갯수가 짝수가 되도록 parity bit를 설정한다.
                - parity bit = 1
            
              
            
3. RAID-4
    
    ![[Source/Untitled 3 48.png|Untitled 3 48.png]]
    
    블록-단위 인터리빙 방식 사용
    
    비트 단위보다 더 빠르게 읽고 쓸 수 있다.
    
    문제점
    
    데이터를 업데이트하면 패리티 디스크도 업데이트를 해야한다.
    
    매 쓰기 동작마다 패리티 디스크를 두 번씩 액세스
    
    병목 현상 발생
    
      
    
4. RAID-5
    
    ![[Source/Untitled 4 35.png|Untitled 4 35.png]]
    
    RAID-4의 문제점을 보완하기 위하여 패리티 블록들을 라운드 로빈 방식으로 분산 저장
    
    장점
    
    패리티 디스크에 대한 병목 현상 해소
    
    쓰기 동작들의 병렬 수행 가능
    
    단점
    
    작은 쓰기 문제
    
    어느 한 블록만 갱신하면 네 번의 디스크 액세스 필요 → 성능 저하
    
    큰 쓰기의 경우 패리티 블록을 미리 계산하여, 새로운 데이터 및 패리티 블록을 한 번씩만 쓰면 된다.
    
      
    
- 현재는 RAID-1과 RAID-5를 많이 사용한다.
    
    - RAID-1은 비싸도 확실해서 사용
    - RAID-5는 블락 단위 데이터 저장, 쓰기 동작 발생 시 최소 쓰기 동작 및 병렬 수행 가능해서 사용
    
      
    
## 6.3 플래시 메모리와 SSD
- 플래시 메모리
    
    - 전원이 없어도 데이터 저장이 가능한 비휘발성 저장장치
    - HDD와 달리 기계 구동이 아니라 데이터를 읽고 쓰는데 HDD보다 적은 시간이 걸린다.
    
      
    
- 플래시 메모리
    
    - NAND게이트가 메모리 주제에서 등장하는 이유
        
        - [NAND와 래치](https://bugoverdose.github.io/computer-science/latch-and-flip-flop/) : 데이터 저장을 위해 사용
            
            래치
            
            ![[Source/Untitled 5 26.png|Untitled 5 26.png]]
            
            초기 in을 0, 그로 인한 출력값 또한 0이라고 가정
            
            이후 1이 입력되면 출력값은 무조건 1
            
            즉 out = 1
            
            out인 1은 그대로 입력값으로 들어오며 or게이트는 1과 1을 입력값으로 받는다.
            
            이렇게 출력값을 자신의 입력값으로 사용하는 순환구조를 `피드백`이라고 한다.
            
            피드백으로 인해 in이 0이 되더라도 or 게이트의 출력값은 여전히 1로 유지될 수 있다. ( 0 or 1 = 1)
            
            이처럼 입력값을 외부로부터 꾸준히 입력받지 않더라도, 특정한 출력값을 유지할 수 있는 구조의 회로가 ==래치==의 특성이다
            
            여기까지 출력값을 1로 설정하는 방법
            
            ---
            
            하지만 다시 출력값을 0으로 되돌리는 것은 불가능하다.
            
            자유자재로 1로 값을 설정하고, 0으로 값을 리셋하기 위해선 피드백에 간섭할 수 있는 수단을 추가해야한다.
            
            ![[Source/Untitled 6 20.png|Untitled 6 20.png]]
            
            이것의 구체적인 내용은 링크 참고
            
            ---
            
            위와 같은 래치 방식으로 회로 내의 비트 단위 데이터를 자유롭게 저장할 수 있다.
            
            래치를 구현할 수 있는 다양한 방식이 있는데 가장 보편적인 구조 S-R 래치 구조이다.
            
            ![[Source/Untitled 7 20.png|Untitled 7 20.png]]
            
            자세한 내용은 링크 참고
            
            ---
            
            결과적으로 래치, 그 중 가장 보편적인 S-R래치와 그것에 사용되는 NAND 게이트의 핵심은 데이터 저장이다.
            
        - 클록
            
            시간의 경과를 알려주는 데이터 입력값 자체를 의미
            
            ![[Source/Untitled 8 17.png|Untitled 8 17.png]]
            
            주기적으로 0과 1사이의 출력을 오가는 회로 내의 부품을 발진자(oscillator)라고 한다.
            
            출력값을 입력값으로 받음으로써 주기적으로 값이 1이 되었을 때에만 특정 작업을 반복하여 수행하도록 설정할 수 있다.
            
            하지만 이렇게만 회로를 구성하면 전파 지연으로 주기가 불안정
            
            크리스탈과 같이 별도 부품이 필요
            
            이 클록을 래치의 입력값으로 받아 적절하게 사용해서 아래 문제들을 해결할 수 있다.
            
            안정성 문제
            
            데이터 변화 시점
            
            의도치 않은 데이터 변경 차단
            
            전파 지연
            
            입력값이 게이트를 지나는데 걸리는 시간 존재
            
              
            
        - 플리플롭
            
            비트 단위로 데이터를 저장하는 회로 구조
            
            ![[Source/Untitled 9 15.png|Untitled 9 15.png]]
            
            D -플리플롭
            
            플리플롭
            
            에지에 의해 데이터 변화가 촉발되는 래치
            
            D 플리플롭
            
            양의 에지에 의해 변화가 촉발되는 래치
            
            ---
            
            이후 내용은 링크 참고
            
        
          
        
    
    높은 저장 밀도
    
    낮은 전력 소모량, 높은 신뢰성, 속도 향상
    
      
    
6.3.1 플래시 메모리 다시 공부하기
  
![[Source/Untitled 10 12.png|Untitled 10 12.png]]