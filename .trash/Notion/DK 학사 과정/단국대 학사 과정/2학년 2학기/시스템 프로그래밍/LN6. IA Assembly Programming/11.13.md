## 복습
시프가 무엇이냐
CPU를 보는 여러가지 관점
우리 수업에서는 ISA의 관점에서 본다
ISA으로 본다는 것은?
CPU에 어떤 레지스터 모델? 메모리? 어떤 명령어?
  
레지스터 모델
크게 4가지 정의
범용
범용으로 사용 가능
스택포인터 버퍼 포인터도 있다
세그먼트
데이터 세그먼트의 시작 위치 등
ELAGS
cpu의 상태 및 제어 비트 유지
명령어 포인터 EIP
  
메모리 모델
인텔 cpu는
로지컬 어드레스
세그멘터이션으로 리뉴어
리뉴어
페이징으로 피지컬
피지컬
  
세그멘테이션과 페이징을 자세히 알아보자
  
## Segmentation & Paging
왼쪽은 세그멘테이션만 오른쪽은 페이징
세그는 가변크기, 페이징은 고정크기
개발자가 보는 버츄얼 메모리는 0부터 11까지 구성(가정)
세그는 가변 크기로 이를 나눈다.
15페이지에서는 2개로 나누었다.
0~4 S1, 5~11 S2
세그 사이즈가 가변적이다.(5개, 7개)
페이징은 고정크기(15페이지에서는 4개)로 나눈다.
cpu는 세그 혹은 페이징 혹은 둘다 사용한다.
인텔 cpu는 둘 다 지원한다곤 하지만, 최근에는 둘 중 하나, 페이징만 사용한다.
  
물리 메모리 : 여러 프로세스 존재 가능(가상 메모리는 프로세스 독립적으로 사용)
회색: 다른 프로세스들이 이미 사용
흰색 : 사용 안하는 중
  
세그에서 s1은 8번부터 5칸(위로), s2는 40부터 7개 칸(위로)사용할 예정이다.
페이징에서 p1,p2,p3는
  
피지컬 메모리 어디에 올라갔냐를 나타내는 것이 세그먼트 테이블, 페이지 테이블이다.
세그 테이블에는 사이즈가 있지만 페이지 테이블에는 고정 사이즈라 사이즈가 없다.
  
What is th PA of the VA 10 in segmentation? (or Paging)
세그 시작주소 찾고 대응되는 물리 시작주소를 찾고 오프셋만큼 올라가서 찾는다.
페이징도 마찬가지
페이징이 세그보다 주소 계산이 더 쉽다.
페이징은 가변한 수식으로 계산할 수 있어서 유리하다.
  
CPU에서 나오는 주소는 가상 메모리이다.
  
세그먼트 레지스터들이 가상 메모리의 각 주소들의 시작을 가리킨다. p.16
==그림에서 세그, 페이징 차이??==
  
17,18페이지 스킵
세그, 페이징 구현인데 너무 디테일해서 패스
  
## 명령어 모델
레이블 : 주소 역할을 한다.
레이블은 콜론 앞에 있다.
OPcode
기능의 역할을 한다.
operand
기능을 할 때 사용하는 인자.
  
인텔 cpu는 인자의 수를 가변으로 지원한다.
셋 중 반드시 있어야 하는 것은 opcode이다.
레이블은 없을 수 있다.
예시에서도 첫 명령어만 레이블이 있다.
  
오피코드 종류 p.20
1. 범용 오피코드
    
    11가지로 세분화할 수 있다.
    
    1. 데이터 transfer : MOV, PUSH, POP
    2. 산술 연산 : ADD, SUB, MUL,DIV
    3. 논리 연산: AND OR XOR NOT
    4. 시프트 : SHR, SHL
    5. 비트 연산 : BT(비트 테스트), BTS
    6. 제어 transfer : JMP, JE
    7. 함수 관련: CALL RET LEAVE
    8. 문자열 : MOVS, CMPS
    9. 플래그 제어 : STC,CLC
    10. 세그먼트 관련 : LDS, LES
    11. miscellaneous : INT, NOP
    
2. 스페셜 오피코드
    1. 부동소수점 관련
    2. Single Instruction Multifle Data(SIMD) 하나의 명령어를 여러 명령어로 처리하겠다는 의미
    3. String SIMD(SSE)
    4. 시스템 관련 : LGDT, SGDT
수업시간엔 범용 오피코드를 주로 다룬다.
  
## 명령어 디테일
### Data Transfer Instruction
예시 고수준 언어가 오른쪽
gcc -S 로 컴파일하면 어셈블리어가 되니 vi 편집기로 열면 예시처럼 확인할 수 있다.
오퍼랜드 2개중
처음 오퍼랜드를 소스, 뒤 오퍼랜드를 데스티네이션이라고 부른다.
add의 경우 더한 값을 뒤에 저장한다.(데스티네이션에 저장한다.)
윈도우는 앞 쪽이 데스티네이션, 뒷 쪽이 소스이다.
  
오퍼랜드를 사용할 때 앞에 접두어를 사용한다.
% : 레지스터이름
$ : 상수(리터럴)
아무것도 없음 : 메모리
  
인텔 cpu는 CISC머신임을 알 수 있다.
ex : incl(인클리먼트)
  
b가 short라서 %eax가 아니라 %ax에 담았다.
  
movw 워드 단위로 이동
movb 1바이트 이동
ppt 보고 마저 적기
  
AT&T vs Macro (둘다 인텔)
source, destination 위치 차이
movl vs mov 키워드
달러 표시 유무
  
### 산술연산 명령어
==로드 스토어 아키텍처==
메모리에서 읽거나 쓸 때 고유한 명령어만 사용해서 접근한다.
메모리에 접근할 때 mov만 사용
그런데 뺄쌤할 때도 mov만 쓴다면 로드 스토어 아키텍처에 어긋난다.
사칙연산하는데 메모리를 인자로 사용해도 어긋난다.
  
파이프라인, 슈퍼스칼라
CPU는 로드 스토어만 하거나 계산만 하는 등 하나에만 집중하는 것이 속도가 빠르다.
A가 그것을 지켜 더 빠르고 B는 병렬적으로 잘 처리하지 못해서 느리다.
곱셈은 덧셈보다 복잡하다.
덧셈은 결과가 많아봤자 1자리 수 증가인데 곱셈은 그렇지 않다.
곱셈은 2개의 레지스터를 사용해야한다. → %edx (11페이지 참고)
mull %ebx 처럼 곱셈 나눗셈은 인자가 하나다
곱셈: 주어진 오퍼랜드 ebx와 묵시적으로 eax를 곱해서 edx:eax에 저장한다.(상위 32비트는 edx, 하위 32비트는 eax에 저장)
나눗셈은 edx:eax를 주어진 오퍼랜드로 나누어 몫은 eax에, 나머지는 edx에 저장한다.
시프트로 곱셈을 처리할 수도 있다.
시프트가 속도가 훨씬 빠르므로 gcc로 컴파일하면 시프트 방식으로 어셈블리어가 생성된다.
b * 7 = b * 8 - b
이런 식으로 시프트한다.
  
### Control Transfer Instruction(If)
레이블을 사용한다.
cmpl은 컴페어 명령어이다.
뒤에서 앞을 빼고(ALU에서) 그 결과를 데스티네이션에 저장하지 않는다.
덧셈, 뺄셈을 하면 EFLAGS가 바뀌는데 그 중 ZF, SF으로 그 결과가 0, 양수, 음수를 판별한다.
jle: “점프 less or equal 하다면”이라는 조건이 있는 점프 명령어이다.
jne : “equal 이라면 점프”라는 뜻
  
makefile