fork를 하면 새로운 쉘을 만든다.
여러개의 프로세스가 동작하는 시스템을 멀티태스킹이라고 한다.
  
## 멀티태스킹 시스템
멀티태스킹시스템에선 새로운 이슈가 생긴다.
- 스케줄링 & Context switch
    
    타임 쉐어링 시스템으로 해결(시분할시스템)
    
    Context switch를 수행한다.
    
    어디까지 수행했는지 기억했다가 복구했다를 반복(LN7에서 다룬다.)
    
- 메모리 관리
- IPC
    - 프로세스간에 정보를 주고받게 한다.
    - ex: 파이프
- ==경쟁 상태(Race Condition)==
    - 동기화(Synchronization)이 필요하다.
- Thread
  
## advanced precess system calls
signal(), kill(), alarm()
signal() : 전화에 비유. 비동기적인 사건.
현재 읽고있던 책을 멈추고 전화를 받는다. 전화가 끝나면 읽고있던 부분부터 책을 다시 읽는것과 같다.
프로세스를 실행하다가 시그널을 받으면 프로세스를 멈추고 시그널을 handle한다.(signal catch function)
kill()
$ kill -9 1234 (이 명령어와 유사하다.)
1234라는 pid를 가진 프로세스에게 9라는 시그널을 보낸다.
alarm()
특정 시간이 되면 알람이라는 시그널을 보내달라 요청한다.
  
sleep(), pause()
프로세스를 잠시 멈춘다.
sleep(2) : 2초 후에 wakeup이라는 시그널을 보내서 프로세스를 “깨운다”.
pause()
시그널을 받을 때 까지 멈춘다.
  
nice(), getpriority(), setpriority()
우선순위와 관련된 호출이다.
각 프로세스엔 우선순위가 있다. (100, 101, 103 등 숫자로 이루어져있다.)
우선순위가 높은(숫자가 작은) 프로세스부터 실행한다.
nice()
우선순위 숫자를 바꿔준다.
nice(-2)를 실행하면 기존 우선순위 숫자에 -2를 한다.
getpriority()
  
sched_setscheduler()
리눅스에선 여러개의 스케줄 정책이 있는데 프로그래머가 선택할 수 있다.
sched_setparam()
time quantum은 보통 10ms이다
time quantum을 변경
  
times()
  
gettimeofday()
8번쨰 강의노트에서 실습
  
ptrace()
디버거에서 많이 사용한다.
다른 프로세스의 프로세스를 제어할 때 사용한다.
  
## fork()가 수행됐을 때 fd가 어떻게 되는가
A프로세스가 만들어지면 task_struct가 만들어지고 그것에 pid와 memory정보, 그리고 fd[ ]가 만들어진다.
  
## Race condition
더미루프 → 시간을 지연하고 싶을 때 사용
임베디드나 IoT에서 센칭할 때 사용한다.
더미 지연
- Concurrency(병행성)
    - fork()하고 나면 여러 프로세스가 동시에 동작하는 것
    - cpu가 여러개 있으면 동시 동작
    - cpu가 하나만 있어도 프로세스가 동시에 동작하는 것 처럼 지원이 된다.
- Shared resource(공유 자원)
    
    여러 프로세스가 동시에 같은 inode, 터미널을 공유한다.
    
    두 개 이상의 프로세스가 동시에 같은 자원에 접근하면 문제가 생긴다. 그것이 경쟁 상태이다.
    
- Race condition(경쟁 상태)
    
    이 상태를 허락하면 안된다.
    
    무언가 순서 관계를 줘야한다. 그것이 Synchronization(동기화)
    
- Synchronization(동기화)
    
    wait()를 사용하면 해결할 수 있다.
    
    wait()는 순서관계 즉 동기화를 주기 위한 방법이다.
    
    아니면 조건 변수를 이용할 수도 있다.
    
    부모의 수행이 끝난 후 조건 변수를 바꿔서 자식이 수행되도록 하면 동기화를 이룰 수 있다.
    
      
    
## 두개의 같은 코드의 프로세스가 동시에 실행되면
각각의 가상 메모리를 가지고 있는 것이므로 여전히 독립적인 프로세스이다.
  
## Thread
Concurrency를 이루는 방법
데이터/파일 부분을 따로 받는다. → 독립적인 모델
![[Source/Untitled 114.png|Untitled 114.png]]
- 프로세스 모델
    - 한 프로세스에서 포크를 하면 새 프로세스가 만들어지고 데이터 파일을 따로 가지고 있는다.(독립적인 모델)
    - 결함을 독립시키는데 용이하다.
    - 데이터를 공유할 때는 별도의 IPC 모델을 사용해야한다.
  
- 스레드 모델
    - 스레드는 한 스레드가 있는 상황에서 데이터/파일 부분을 공유한다.
    - 레지스터, 스택은 공유하지 않고 스레드마다 따로 가지고 있는다.
    - 한 스레드가 죽으면 옆 스레드들이 다 죽는다. (결함 고립이 안된다.)
    - 프로세스모델보다 훨씬 빠르다.
    - 데이터를 공유하기에 좋다.(Sharing)
        - 데이터를 변경하면 다른 스레드에서도 확인할 수 있다.
  
인터넷 익스플로어 : 스레드 모델
한 창에서 문제가 발생하면 다 죽는다.
크롬 : 프로세스 모델
조금 느리지만 한 창이 죽어도 다른 창들은 멀쩡하다.
  
pthread_create() (프로세스 모델의 fork()와 유사)
&p_thread : 쓰레드 핸들
NULL : 쓰레드 파라미터
func : 이 함수를 무조건 수행하고 함수가 끝나면 쓰레드를 종료한다.