ISA를 배웠다.
레이블 - 오피코드 - 오퍼랜드
오피코드의 이슈
얼마나 많이?
멀티 펑션?(SISD SIMD MIMD)
오퍼랜드의 이슈
고정 개수? 가변 개수?
인텔은 가변 개수를 지원한다.
고정인 경우 몇 개로 할 것이냐?
  
오늘 배울 것
Multitasking 문맥 교환
little 앤디안
메모리 얼라인먼트
메모리 오버플로우
  
# 7.2 ISA가 시스템 프로그래밍에 미친 영향
## 멀티태스킹
- 타임 쉐어링 시스템(시분할 시스템)
- 타임 퀀텀(시간 할당)만큼 A프로세스 실행, 그 다음 B프로세스 실행을 반복
    - 리눅스에선 100ms
        - 이 시간은 cpu입장에서 매우 긴 시간이다
        - 충분히 많은 작업들이 수행될 수 있다.
- A프로세스에서 B를 갔다가 다시 A로 돌아올 때 A를 어디까지 수행했는지 기억해둬야한다.
    
    - 이 것을 정의하기 위해 context라는 키워드가 나온다.
        - reg, address space, 열려진 파일, IPCs 등을 통틀어서 context라고 한다.
    
      
    
- 멀티태스킹: 레지스터는 가상 메모리의 어디를 가리키나
    
    - EIP
        - Text 부분의 실행하는 코드를 가리킨다
    - ESP
        - 스택의 탑을 가리킨다.
    - text에 있는 명령어들
        - movl $2, %eax
            - eax에 2 넣기
        - pushl %eax
            - eax에 있는 2를 스택에 push
            - ESP는 한 칸 내려간다.
        - addl %eax, %ebx
    - 이렇게 레지스터를 이용해 잘 수행하던 A를 멈추고 B를 실행하면 어떻게 될까.
    
      
    
    - A가 수행되다가 멈추고 B가 수행된다는 것은 CPU가 A, B 중 어느 것을 가리키고 있냐에 달렸다.
        
        - 물리 메모리에 A, B의 가상 메모리들이 모두 올라와있는 상태이다.
        
          
        
    - A 수행을 멈출 떄 레지스터의 상태를 어딘가에 기억하고 다시 수행할 땐 그것을 불러와야한다.
        - context save
            - 레지스터의 내용을 메모리 어딘가(task strucure)에 저장
            - CPU → task structure(memory)
        - context restore
            
            - 저장했던 레지스터 내용을 불러온다.
            - task structure → CPU
            
              
            
    - timeout, sleep, blocking, IO 상황에서 Context switch가 발생한다.
    
      
    
    - 쓰레드는 제어의 흐름이다.
        
        - 레지스터의 내용이다.
        
          
        
## 메모리 사용
낮은 자리에 낮은 자리 숫자가 있으면 리틀 앤디안
Intel, ARM
낮은 메모리 자리에 앞 자리(높은 자리) 숫자가 있으면 빅 앤디안
sparc, ARM
  
둘의 특성 다름
리틀
덧셈 뺄셈이 빠르다. 효율적
메모리 순서대로 계산하면 자연스럽게 저장된다.
빅
패킷 분석할 때 효율적
메모리 순서대로 읽으면 자연스럽다.
인터넷은 빅 앤디안을 사용
  
readelf를 쓰면 현재 elf에 대해 볼 수 있다.
그러면 앤디안을 확인할 수 있다.
  
## 메모리 얼라인먼트
메모리 단위를 정하고 줄을 맞춰서 차곡차곡 해놓는다. p.18
4바이트 또는 18바이트로 맞추라고 권장받는다.
메모리 얼라인먼트 맞으면
일관성 유지에도 유리하다.
cache coherence protocol
수정되면 같은 캐시에도 그걸 알려주고나 무효화를 시켜야하는 의무
memory alignment가 안 맞으면 가짜로 공유하고 있는 경우가 발생할 수 있다.
그러면 성능이 확 나빠질 수 있다.
  
구조체를 만들 때 **attribute** ((packed)) 를 사용하면 메모리 얼라인먼트 없이 메모리를 꽉꽉 채워서 만든다.
메모리를 아낄 수 있다.
  
- 스택에서 Memory alignment p.19
    
    - s.ebp
        - 스택의 기준(base)
        - ebp의 -4는 첫 번쨰 지역변수이다.
        - ebp의 +8은 첫번째 인자이다.
    - leal -8(%ebp), %eax
        - load effective address
            
            - 주소를 가져오는 역할
            - mov랑 다르게 source의 값이 아니라 주소를 destination에 올린다.
            
              
            
    
    19페이지에서 그린 그림 확인하기
    
      
    
- p.20
    - and가 하는 일은?
    - 저번에 질문한 것
    - andl $-16, %esp
        - 11…110000과 and 연산
        - 최하위 네 개의 비트를 0으로 만든다.
        - 즉, 16의 정수승이 되게 만든다.
            
            - 스택프레임의 alignment를 맞춘다.
            - 멀티코어 환경에서 충돌이 줄어든다
            
              
            
## Memory Overflow
- 초기 gets(get string) 함수는 바운더리 체크 x
    - 그림 참고
    - 입력받은 글자가 아래부터 쌓인다
    - 8글자가 넘어가면 문제가 생긴다.
    - 문자가 많아져서 return address까지 건든다면 메모리 오버플로우
- Stack randomization
    - 스택의 지역변수를 우리가 배운 것처럼 순서대로 집어넣지 않고 임의의 위치에 집어넣는다.
    - 위치만 기억하면 그래도 상관 없다.
    - 컴파일러가 유연하게 다양한 랜덤 위치로 맞춰서 스택을 설정할 수 있다.
    - p.51을 보면 randomization과 stack protector를 끌 수 있다.
- Stack Protector
    - 스택 가드
    - 스택이 오염된 것을 감지하면 해결한다.
    - 스택 중간에 숫자를 넣어놓는다.(Canary)
    - 카나리가 바뀌지 않았는지 확인했을 때 그대로면 스택 오버플로우 x
        - xor 연산으로 비교한다.
    - p.22 그림 확인