## |Programming environments
  
### |Simple Simulation of Duck
- 잘 짠 코드에서 발생하는 문제 !
    
    - 어라? 인터페이스 추상화에는 없는 기능을 가진 자식을 어떻게 상속 시키지?
    - 오버라이드가 해결책인데? 자주 하는 일이 발생 할 수 있다.
        - 변화가 시작되면서 코드가 엉망이 되간다. 모디피케이션이 자주 발생한다.
    - 다중 상속은 어떤가? 기능을 따로따로 만들어서 상속 시키자.
        - 코드의 길이가 매우매우 길어지기 시작한다.
        - 상속 깊이가 5를 넘는 것은 좋지 않으며 또한 중심이 있고 가지가 있는 상속을 해야한다.
    - 그럼 추상화한 객체를 멤버 변수로 가지는 것은 어떤가? → 전략 패턴
        - 예를 들어 오리의 fly 기능을 fly() 인터페이스의 자식 클래스의 객체를 상속하게 하는 것이다.
        - 새로운 기능이 생겼을 때 추상화한 객체만 수정하면된다.
            - 새로운 fly, 예를 들어 푸드덕 날기 기능이 새로 생긴다면 fly 인터페이스의 자식으로 푸드덕 날기 클래스를 구현하고 그 푸드덕 날기 클래스의 객체를 푸드덕 나는 오리가 멤버 변수로 갖게 한다.
        - Open/Close의 구현이 가능하다.
        - Dependency Inversion Principle
    
      
    
## |Strategy Pattern
![[Source/Untitled 141.png|Untitled 141.png]]
- Open for extension과 Close for Modification이 좋다.
- 확장성이 좋고 변화가 적다.
- 추가만으로 해결 가능하다.
- 지속적인 확장이 발생하고 기존코드에 대한 변화가 일어날 때 사용하는 것이 좋다.