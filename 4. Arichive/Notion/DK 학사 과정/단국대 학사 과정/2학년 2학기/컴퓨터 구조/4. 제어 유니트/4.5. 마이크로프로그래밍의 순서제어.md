![[Source/Untitled 127.png|Untitled 127.png]]
  
- 제어 유니트가 명령어의 실행을 제어한다는 것의 의미
    - 제어 기억장치엔 마이크로 명령어들이 저장되어있는데
    - 해당 마이크로 명령어를 순서대로 인출하는 동작인 것이다.
  
- 순서 제어
    - 위 그림에서 제어 기억장치를 제외한 상단의 모듈들은 다음에 실행할 마이크로명령어의 주소를 결정하는 회로들이다.
    - 그 다음에 실행할 명령어의 주소를 결정하는 기능을 “순서 제어”라고 한다.
    - 핵심 요소는 다음에 인출할 마이크로명령어의 제어 기억장치 주소를 가지고 있는 CAR이다.
        - CPU를 처음 시작할 때는 CAR을 0으로 세팅한다.
            - 즉 인출 사이클 루틴의 첫번째 마이크로명령어를 인출하면서 시작한다.
  
- CD필드의 두 비트들 → MUX2로 보내진다.
    - 4개의 조건 비트 중 하나를 선택한다.
        - 1, I, S, Z
  
- MUX2의 결과값은 주소 선택 회로의 한 입력(C)으로 들어간다.
- C와 함께 BR 필드의 두 비트가 주소 선택 회로의 입력으로 들어간다.
  
![[Source/Untitled 1 82.png|Untitled 1 82.png]]
- BR 필드가 00(JUMP) 또는 01(CALL)을 기리킬 때,
    - 조건이 만족되지 않으면
        - CAR의 내용이 1 증가한다.
        - 다음에 위치한 마이크로 명령어를 실행하게 된다.
    - 조건이 만족하면
        - 목적지 주소인 주소 필드값(ADF)이 CAR로 적재된다.
        - CAR에 ADF가 적재되기 전, CAR에 저장되어있던 주소는 SBR에 저장한다.
            - 이 동작은 제어 신호 L에 의해 이뤄진다.
  
  
SBR은 Call, RET 명령 때 쓰이는 스택과 유사하다.
MUX의 ==1은 무조건 점프(??)== / 조건을 선택해서 주소 선택 회로로 보낸다.
  
![[Source/Untitled 2 55.png|Untitled 2 55.png]]
조건이 1이면 점프
BR이 00 / 01일 때는 호출문 → SBR도 1이어야 호출을 하고 0이면 그냥 다음 명령어 실행
[[4.3. 마이크로명령어의 형식]]
  
## 제어 신호의 생성
마이크로프로그래밍에서 op code를 제어 유니트의 외부에 보내는 방법이 몇 가지 있다.
==마이크로명령어 내 연산 필드 비트==들이
  
1. 수직적 마이크로프로그래밍(vertical microprogramming)
    
    마이크로 명령어의 연산 필드의 적은 수의 코드화된 비트들을 포함
    
    마이크로 명령어의 길이(비트 수)를 줄일 수 있다.
    
    나중에 해독기를 이용하여 필요한 만큼 제어 신호들로 확장
    
    장점: 길이(비트 수) 최소화 → 제어 기억장치 용량 감소
    
    단점: 해독 동작에 걸리는 만큼의 지연 시간 발생
    
      
    
2. 수평적 마이크로프로그래밍(horizontal microprogramming)
    
    마이크로명령어 내 연산 필드들의 각 비트와 제어 신호를 일대일로 대응시켜,
    
    그 수만큼의 비트들로 이루어진 마이크로명령어를 사용하는 방식
    
    연산 필드를 애초에 넉넉하게 잡는다.
    
    장점: 해독기가 필요없어서 하드웨어가 간단
    
    해독에 따른 지연 시간 없다.
    
    단점
    
    마이크로명령어의 길이 증가
    
    제어 기억장치의 용량이 커진다.