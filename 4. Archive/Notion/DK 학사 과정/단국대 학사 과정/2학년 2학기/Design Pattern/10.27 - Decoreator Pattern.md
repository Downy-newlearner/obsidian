  
- 오버로딩, 오버라이딩 그리고 다형성
    
    다형성은 개념
    
    오버로딩, 오버라이딩은 기능
    
      
    
    다형성은 객체지향언어의 철학이고
    
    오버로딩은 객체 지향이 아니라도 만들수 있는 기능이다.
    
      
    
    같은 이름에 다른 일을 한다 : 오버로딩
    
    인터페이스나 추상 메소드는 부모가 자식에게 강요하는 구조이다.
    
    다형성을 구현하려면 오버로딩을 써야하는 것이다.
    
    오버로딩은 그 자체로 존재하는데 오버로딩을 특이하게 쓴 경우가 다형성이다.
    
      
    
    오버라이딩은 강요받은 자식이 거부하는 것이다. 부모가 준 것을 다른 것으로 바꿔치기 할 때 오버라이딩이다.
    
    부모가 구현을 했는데 자식이 구현된 코드 말고 다른 걸 쓰겠다고 하면 오버라이딩이다.
    
    생성자가 여러개 있다는 것은 오버라이딩이 맞다.
    
      
    
    부모가 자식에게 무언가 해 달라고 요청하는 것
    
      
    
    객체지향이 아니면 다형성을 구현할 순 없다.
    
    ex : c → c++ → GO (구조적 언어 → 객체 지향 언어 → 구조적 언어)
    
    객체지향에서 코드 재사용을 상속으로 만들면서 치명적 약점이 생겼다 → 다중 상속
    
    ex: 외할아버지 성과 나의 성이 다름
    
    어떤 것을 재사용? 같은 케이스면?? 그게 과연 재사용인가?
    
    상속할 떄는 메모리에 일렬로 쭉 쓰는데 다중 상속은 그게 안된다.
    
    상속을 부인하고 싶어서 자바는 extends(상속은 하나만), implement(인터페이스 구현은 여러개 가능)
    
    GO에서 구조적 언어로 회귀한 이유가 다중상속을 피하기 위해서이다. 그래서 GO에는 다형성이 없다.
    
      
    
    같은 이름으로 다른 기능을 한다 → 오버로딩
    
      
    
- Decorator Pattern
    
    ![[Source/Untitled 85.png|Untitled 85.png]]
    
    file - Diretory TextFIle ImageFile 는 1대 다 관계이다.
    
    최초의 파일이 있는데 그 파일이 디렉토리이어야 이야기가 시작되는거 아니냐. 최초의 파일이 텍스트 파일이면 트리 구조를 못 가진다.
    
      
    
      
    
    ![[Source/Untitled 1 58.png|Untitled 1 58.png]]
    
    상속의 개념에서 어떤 구체적인 물건의 상속은 좋은 개념이 아니다. 우리가 보통 쓰는 상속에서 상속을 만들 때 보통 상속의 깊이를 4이상 들어가지 말라는 이야기를 많이 한다 그 이유가 여기에 있다.
    
    상속의 깊이보단 위에 원래 있었던 객체를 재사용하자는 의도에서 벗어나면 그 때부턴 모든 문제가 발생한다.
    
    상속 구조를 만들고 싶다면 대게는 개념상의 계층을 가지고 있는 등 해야지 나중에 문제가 없이 해결이 된다.
    
    상속은 그렇게 좋은 제도가 아니다. 70년대의 호주에서 오리너구리가 발견되었을 때 생물학계가 완전 무너졌다.
    
    오리너구리는 젖을 먹이고 알을 낳고 수영을 하는 등 포유류, 파충류, 조류 의 특징들을 모두 가져 생물 계층에 집어넣을 수가 없다.
    
    우리가 계층을 잘못 짜면 시스템에 오리너구리같은 존재가 나타난다.
    
    객체 지향의 개념에서 상속의 개념은 코드의 재사용이다. 다른 걸 쓰지 마라
    
    선물인데 그게 포장지였고 포장지가 박스였따. 그게 그림 하나를 설명할 수 있다.
    
    이 선물은 패킹 안에 다시 선물이 들어갈 수 있다. 선물이 패킹 종류면 그 속에 다시 선물이 들어갈 수 있따. 다시 패킹을 열어봤는데 캔디일 수도 있다. 패킹 안에 패킹(선물) 그 선물 안에 패킹(선물) 그 선물 안에 사탕. 이런 구조가 가능한 것이다.
    
      
    
      
    
    예시
    
    ![[Source/Untitled 2 42.png|Untitled 2 42.png]]
    
    스크롤이 존재한다
    
    ![[Source/Untitled 3 37.png|Untitled 3 37.png]]
    
    이렇게 바꾸면 오른쪽에 없던 스크롤이 생긴다.
    
      
    
    동적 컨퍼런스를 붙이기 위해 우리는 객체 구조를 이렇게 만들면 도구 바가 붙었다 안 붙었다 이런 기능을 동적으로 만들 수 있지 않겠느냐 라는 것이 Decorator Pattern의 아이디어
    
      
    
    만일 커피가 있는데 커피의 옵션을 따질 거면 체크박스만 두면 된다
    
    ex 커피 옵션에는 우유, 시나몬가루, 바닐라 시럽 등이 있다.
    
    커피에 어레이 리스트를 만들고 리스트의 옵션마다 체크박스를 두면 된다.
    
      
    
    그런데 첨가물이 자꾸 늘어난다.
    
      
    
    사실 커피 얘기가 좋은 예는 아님
    
    동적으로 만든 것이 다른 동작으로 보여줄 때가 이 패턴의 진가를 볼 수 있다.