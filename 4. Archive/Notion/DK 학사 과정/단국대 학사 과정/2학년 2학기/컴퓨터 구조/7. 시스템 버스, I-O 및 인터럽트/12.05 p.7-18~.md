  
# 7.2 버스 중재
- 병렬 중재 방식
    - 중앙집중식 고정 우선순위 중재 방식
    - 분산식 고정 우선순위 방식
    - 가변 우선순위 방식
        - 동등 우선순위
        - 임의 우선순위
        - 최소-최근 사용
- 직렬 중재 방식
    - 중앙집중식 직렬 중재 방식
    - 분산식 직렬 중재 방식
- 폴링 방식
    - 하드웨어 폴링 방식
    - 소프트웨어 폴링 방식
  
# 7.2.1 병렬 중재 방식
마스터에서 선이 나와서(각각 다른 선) 중재기로 들어가는 방식
중재기가 많아질수록 사용하는 선의 개수가 늘어난다.
## 1)중앙집중식 고정 우선순위 중재 방식
![[Source/Untitled 135.png|Untitled 135.png]]
- BREQ
    - 버스 요구 신호
- BGNT
    - 버스 승인 신호
- BBUSY
    - bus busy
  
`회로 이해하기`
## 2)분산식 고정-우선순위 방식
![[Source/Untitled 1 89.png|Untitled 1 89.png]]
- 모든 마스터에 중재기가 하나씩 있다.
- 각 중재기는 자신보다 높은 우선순위를 가진 마스터들의 버스 요구 신호들을 받아 검사
- 그들의 요구가 없는 경우에만 자신의 버스 마스터로 버스 승인 신호 발생
- 승인 신호를 받은 후 BBUSY 신호 검사 후 비활성화 상태라면 버스 사용 시작
  
- 장점
    - 중앙집중식에 비해 회로가 간단하다.
- 단점
    - 중재기가 고장일 때 어디서 고장났는지 찾기 어렵다
        - 한 중재기의 고장이 전체의 고장을 초래한다.
`회로 이해하기`
  
## 3)가변 우선순위 방식
![[Source/Untitled 2 61.png|Untitled 2 61.png]]
- 장점
    - 회로 복잡
- 단점
    - 모든 마스터들이 공정하게 버스를 사용할 수 있도록 해준다.
  
- 방법 1
- 방법 2
    - circular queue 방식이다.
    - 예를 들어 마스터 3의 요구가 승인된 후에 마스터 4가 최고 우선순위가 된다.
  
- 방식 종류
    - 동등 우선순위 방식
        - 모든 마스터들이 동등한 우선순위를 가지며 FIFO 알고리즘 사용
        - 먼저 들어오는 마스터가 먼저 우선순위를 받음
    - 임의 우선순위 방식
        - 각 중재 동작이 끝날 때마다 우선순위를 임의로 결정
    - 최소-최근 사용
        - 가장 오랫동안 버스를 사용하지 않은 버스 마스터에게 최상위 우선순위 할당
        - 소프트웨어 방식이 아닌 하드웨어 방식이므로 최근에 사용한 버스에 대해 저장하는 버퍼가 필요하다.
            
            - 회로가 매우 복잡하다.
            
              
            
# 7.2.2 직렬 중재 방식
## 1)중앙집중식 직렬 중재 방식
![[Source/Untitled 3 49.png|Untitled 3 49.png]]
- 하나의 BGNT가 데이지 체인 형태로 모든 버스 마스터들을 직렬 연결
- 우선순위는 BGNT 연결 순서로 결정
- 동작 원리
    - 어느 버스에서 요청 발생
    - 버스 중재기에서 데이지 체인의 첫 번쨰에 접속된 마스터로 BGNT 전송
    - 연결된 순서대로 BGNT 신호를 넘기고 넘기다가 버스 사용을 요구한 상태인 마스터를 만나면 버스 사용권 부여
        
        - 이런 방식으로 인해 중재기에 가장 가까운 마스터의 우선순위가 높은 것이다.
        
          
        
## 2)분산식 직렬 중재 방식
![[Source/Untitled 4 36.png|Untitled 4 36.png]]
- 데이지 체인 버스 승인 신호(DBGNT)선으로 버스 중재기들을 순환형으로 접속
- 각각의 마스터에 중재기가 따로 있다.
- 우선순위
    - 각 마스터의 우선순위가 계속 변화
    - 버스 사용 승인을 받으면 다음 중재 동작에서는 최하위 우선순위를 가짐
    - 버스를 사용한 마스터의 바로 우측에 위치한 마스터가 최상위 우선순위를 가짐
    - 순환형 구조에서 DBGNT 신호가 연결된 순서대로 우선순위가 결정
  
# 7.2.3 폴링 방식
- 폴링 방식의 원리
    - 중재기가 마스터에 ‘폴링’, 즉 먼저 묻는다.
  
## 1)하드웨어 폴링 방식
![[Source/Untitled 5 27.png|Untitled 5 27.png]]
- 방식
    - 버스 중재기와 각 버스 마스터 간에 별도의 폴링 선이 존재
    - 2진 코드화된 폴링 주소를 이용하면, 폴링 선의 수가 log2N개로 감소
    - 공통의 BREQ선과 BBUSY 선이 각각 한 개씩 존
  
- 동작 순서
    - 중재기는 폴링 주소를 발생하여 검사할 마스터 지정 후 버스 사용을 원하는지 먼저 묻는다.
    - 클라-서버에서 클라가 요청을 한다. 그런데 서버가 먼저 체크하는 것이 폴링방식이다.
    - 지정된 마스터가 버스 사용 원하면 BREQ 신호 세트
    - BREQ 신호가 세트되면 중재기는 검사 중인 마스터에게 버스 사용 허가
    - 세트 안되면 다음 마스터에 폴링
- 우선순위 결정 방법
    
    - 중재기가 마스터를 검사하는 순서에 의해 우선순위 결정
    - 검사할 마스터의 번호는 2진 카운터를 이용하여 발생
    
      
    
## 2)소프트웨어 폴링 방식
- 동작 원리
    - 폴링의 순서와 과정을 버스 중재기 내에 프로세서가 관장
- 단점
    - 프로그램 실행으로 HW 방식에 비해 속도가 느림
- 장점
    - 우선순위(폴링 순서)의 변경에 용이
  
버스 마스터에는 IO디바이스가 연결되어있다. IO에서 CPU로 연결할 떄 어떻게 하는지에 대한 이야기였다.
  
# 7.3 I/O 장치의 접속
## 7.3.1 IO제어
- IO장치의 접속을 하게 되면 IO장치에서 데이터를 읽어올지, 쓸지 등에 대한 제어를 해야한다.
- 마스터
    - CPU가 IO장치와 데이터를 주고받는데에 중간다리 역할을 해준다.
- IO장치가 시스템 버스에 직접 접속되지 못하는 이유
    
    - IO장치는 종류에 따라 제어 방법이 서로 다르다.
    - 데이터를 CPU와 직접 교환하기엔 속도가 너무 차이나서 안된다.
    
    →인터페이스 장치인 IO제어기를 사용한다.
    
      
    
- IO제어기 주요 기능
    - IO 장치의 제어와 타이밍 조정
    - CPU와의 통신 담당
    - IO 장치와의 통신 담당
    - 데이터 버퍼링 기능 수행
    - 오류 검출
  
- 프린터 제어기의 내부 구성도
    
    - 상태 제어 레지스터
        - 내부적으로 두 개의 레지스터로 구성되지만 주소는 하나만 지정되는 레 지스터들
            - 상태 레지스터
                - 출력을 위해선 현재 어떤 파일을 출력할 수 있는 상태이냐를 체크해야한다.
            - 제어 레지스터
                - 쓰기(프린터에 데이터 출력)신호를 프린터에 보내야한다.
            - 상태 레지스터로부터는 읽기만 하고, 제어 레지스터로는 쓰기만 하기 때문에, 두 레지스터들에게 주소를 한 개만 지정해도 되는 것이다.
    - CPU가 프린터로 데이터를 출력하는 과정
        1. CPU가 프린터 제어기에게 프린터의 상태를 검사하도록 요청
        2. 제어기는 프린터 상태를 검사아혀 준비 여부를 가리키는 비트 세트(RDY 비트 세트)
        3. CPU는 RDY 비트를 검사하고 프린터가 프린트 시작 준비가 된 상태라면 제어기로 출력 명령과 데이터를 전속
        4. 제어기는 프린트 동작을 제어하기 위한 신호와 데이터를 프린터로 전송
    - 데이터 레지스터를 큰 데이터 버퍼로 대체하면, 데이터 블록 전체를 한꺼번에 전송받아 프린트 가능
    
      
    
## 7.3.2 IO 주소지정
- 각 IO 장치당 두 개씩의 주소 할당
    
    - 데이터 레지스터 주소
    - 상태/제어 레지스터의 주소
    
      
    
기억장치 사상 사용하면
현재 메모리 접근방식 똑같이 사용
주소도 원래 방식 주소 사용
분리형 IO
IO에 접근하는 명령어를 따로 만들어야함
다른 방식의 주소도 사용해야함
  
### 1)기억장치-사상 IO
IO제어기 내의 레지스터들에게 기억장치 주소 영역의 일부분을 할당하고, 기억장치와 같은 방법으로 액세스하는 방식
- 이미 존재하는 명령어들을 그대로 사용할 수 있다.
    - 아래 명령어들 확인
- 상태 레지스터
    - 최하위 비트(b0) : RDY 비트로 사용
    - 최상위 비트(b7) : 프린트 시작(start) 비트로 사용
  
- 기억장치-사상 IO의 예
- TEST:
    - LOAD 513
    - ANI 01
        - 상태 레지스터는 보통 8비트
        - ANI는 and 연산이다.
        - 최하위 비트인 RDY 비트를 제외하고 나머지 모든 비트들을 0으로 리셋
- 장점
    - 프로그래밍에 용이
- 단점
    - 기억장치 주소 공간이 감소(절반)
### 2)분리형 IO
- JZ TEST
    - JZ는 CPU 안 제로비트가 0이라면 즉 RDY가 안됐다면 TEST로 점프
    - 결국 프린터가 준비될 때까지 이 루프를 계속 돈다.
- 장점
    - IO 주소공간이 기억장치 주소 공간과는 별도로 지정될 수 있어서 기억장치 주소 공간이 감소하지 않는다.
- 단점
    - 기억장치 명령어와 다른 별도의 명령어를 사용해야하므로 프로그래밍이 불편하다.
  
  
# 7.4 인터럽트를 이용한 IO
- 인터럽트 구동 IO
    - CPU가 IO의 상태를 확인하기 위해서 계속 루프를 돈다는 것은 CPU 시간을 낭비한다는 것이다
        
        →인터럽트를 이용하여 IO 디바이스와 커뮤니케이션해서 해결할 수 있다.