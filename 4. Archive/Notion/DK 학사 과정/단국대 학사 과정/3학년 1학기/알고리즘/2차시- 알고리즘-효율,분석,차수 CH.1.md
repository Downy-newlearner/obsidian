증명하는 방법이 시험에 나오지는 않는다.
  
---
p.21
**피보나치 수열: 재귀 알고리즘**
재귀 알고리즘으로 피보나치 수열을 구하면 수행속도가 매우 느리다.
같은 피보나치 수를 중복해서 계산하기 때문이다.
  
**T(n) 구하기(fib(n)을 구하기까지 fib() 함수를 호출하는 횟수)**
`p.24,25쪽 식 작성 연습하기`
  
**피보나치 수열: 반복 알고리즘**
반복 알고리즘은 중복 계산을 하지 않기 때문에 수행속도가 훨씬 더 빠르다.
T(n) = n+1
  
**재귀 vs 반복**
![[Source/Untitled 75.png|Untitled 75.png]]
  
---
p.29 알고리즘 분석
**시간 복잡도 분석**
입력 크기를 기준으로 단위 연산을 몇 번 실행하는지 구하는 것이다.
어떤 경우에는 입력 크기 및 입력 값에도 좌우된다.
  
**알고리즘 분석 종류**
|   |   |
|---|---|
|복잡도가 영향을 받는 것|종류|
|입력 크기|일정 시간 복잡도|
|입력 크기 & 입력 값|최악의 경우 분석, 평균의 경우 분석, 최선의 경우 분석|
**일정 시간 복잡도 분석**
입력값과 무관하게 복잡도가 일정한 경우(예를 들어 배열의 원소 모두 더하기)
**최악의 경우 분석**
복잡도는 입력 크기와 입력 값 모두에 종속
예를 들어 이진 탐색에서 첫 mid가 key의 인덱스라면 걸린 시간은 1, 반면 low 또는 high가 key의 인덱스라면 훨씬 더 오래 걸린다.
이것이 ‘복잡도가 입력 값에 종속되어있다’의 의미이다.
**평균의 경우 분석**
모든 입력에 대해서 단위연산이 수행되는 기대치(평균)
**최선의 경우 분석**
단위 연산이 수행되는 횟수가 최소(최선)인 경우 선택
---
p.32
배열 덧셈 알고리즘
루프는 배열의 값과 무관하게 항상 배열의 크기, n 만큼 반복
교환 정렬 알고리즘
for문 2개를 이용해서 정렬
$T(n) = n(n-1)/2$﻿
순차 검색 알고리즘
최악의 경우, $W(n) = n$﻿
평균의 경우, $W(n) = n/2$﻿
최선의 경우, $B(n) = 1$﻿
  
---
시간 복잡도 분석
정확도 분석
  
---
About JAVA
**자바 소개**
**이클립스 환경 설정 및 실행**
**자바 사용하기**
데이터 타입과 변수
Scanner
연산자
조건, 반복문
배열
**객체 지향**
캡슐화
상속
다형성
**클래스와 객체**
클래스와 객체 생성하기
Data, SimpleDateFormat, Calender 클래스
Math 클래스
  
수업 시간에는 50페이지 분량의 About JAVA를 훑기만 했다.
무엇을 공부해야할지는 앞으로 수업을 들어보면서 고민해보자. 24.03.12