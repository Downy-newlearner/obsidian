분할-정복-취합
분할 정복은 하향식(top-down) 문제풀이 방식이다.
분할정복으로 재귀 알고리즘을 개발할 때 꼭 고려해야 할 사항
분할한 작은 입력사례의 답으로부터 전체 입력사례의 담을 구하는 방법을 고안한다,
더 이상 분할이 불가능한 입력사례를 판단할 종료조건을 정한다.
종료조건을 만족하는 경우 답을 어떻게 구하는지 정한다.
  
  
## 이진검색
의사코드:
![[Source/image 25.png|image 25.png]]
최악의 경우
  
**꼬리 재귀**
호출 이후에 더 이상 연산이 없는 재귀 호출
꼬리 재귀는 재귀 호출 종료 후 해야 할 작업을 스택에 저장해 둘 필요가 없어서 저장 공간을 상당히 절약할 수 있다.
  
## 합병 정렬
![[Source/image 1 11.png|image 1 11.png]]
![[Source/image 2 11.png|image 2 11.png]]
  
  
## 마스터 정리
재귀식으로 표현한 알고리즘의 동작 시간을 점근적으로 계산하는 방법이다.
  
![[Source/image 3 10.png|image 3 10.png]]
## 빠른 정렬
![[Source/Untitled 79.png|Untitled 79.png]]
![[Source/image 4 5.png|image 4 5.png]]
최악의 경우
배열이 이미 비내림차순으로 정렬이 된 경우
![[Source/image 5 5.png|image 5 5.png]]
  
## 행렬 곱셈
행렬 곱셈: 재귀 알고리즘
$T(n) = 8T(n/2) +c ...(n>1)$﻿
$T(1) = 1$﻿
마스터 정리에 의해 $T(n) \in O(n^3)$﻿
  
## 쉬트라센
**쉬트라센에서 곱셈의 수의 일정 시간복잡도 분석**
$T(n)=7T(n/2)...(n>1)$﻿이고
$T(1) = 1$﻿
마스터 정리에 의해 $T(n) \in O(n$﻿^$(log_27))$﻿=O(n^$2.81$﻿)
  
**쉬트라센에서 덧셈/뺄셈의 수의 일정 시간복잡도 분석**
$T(n)=7T(n/2)+18(n/2)^2...(n>1)$﻿
$T(1) = 1$﻿
마스터 정리에 의해 $T(n) \in O(n$﻿^$(log_27))$﻿=O(n^$2.81$﻿)
  
쉬트라센 방법이 단순 행렬 곱셈 방법보다 효율적임을 알 수 있다.
  
## 분할 정복을 피해야 하는 경우
1. 크기 n인 문제를 분할했는데 n과 다를바 없는 크기인 두 개 이상의 문제로 분할된다.
    
    지수 시간 복잡도가 나온다.
    
2. 크기 n인 문제가 n/c 크기의 n개에 가까운 문제로 분할된다.
    
    $O(n$﻿^$log_c(n-1))$﻿의 시간복잡도를 갖는다.
    
      
    
## 분할 정복을 피할 이유가 없는 경우
1. 입력의 크기가 작은 경우
    
    직관적인 이해가 가능해서 입력 크기가 작으면 그냥 쓰면 좋다.
    
      
    
2. 분할정복의 복잡도가 이론적으로 가장 효율적인 경우