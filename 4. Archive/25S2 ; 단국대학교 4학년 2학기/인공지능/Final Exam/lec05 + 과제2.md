# 1부 - 지식 표현(Representation)의 개념과 필요성


## 1. 왜 지식 표현이 필요한가?

AI 시스템은 현실 세계의 사물, 관계, 규칙을 컴퓨터가 이해할 수 있는 방식으로 저장해야한다.
그래야만 추론이 가능해지고, Prolog 같은 논리 기반 언어로 문제를 해결할 수 있다.

과제 2의 모든 문제는 결국 다음 질문에 답하고 있다:

> "사람이 알고 있는 지식(누가 누구를 좋아한다, 누가 부모다)을 Prolog가 이해하도록 어떻게 표현하고, 그 표현을 바탕으로 어떻게 추론할 것인가?

## 2. 지식 표현의 종류와 과제와의 연결

lec05는 표현 방식을 크게 네 가지로 소개한다.

|**지식 표현 방식**|**설명**|**과제에서의 등장 여부**|
|---|---|---|
|**의미망(Semantic Network)**|개념을 그래프로 표현 (is-a, has-a 관계)|서술형(P4)에서 비교 설명|
|**프레임(Frame)**|객체의 속성과 기본값을 저장하는 구조|서술형(P4)에서 비교 설명|
|**술어 논리(Predicate Logic)**|사실·관계를 명제 형태로 표현|**과제 P1~P3의 핵심 기반**|
|**규칙 기반 표현(Production Rule)**|IF-THEN 규칙으로 지식을 표현|Prolog 규칙 작성(P3)과 직결|
즉, 과제 전체는 술어논리(Predicate Logic) -> Prolog 구현의 흐름으로 구성되어 있다.


## 3. 술어 논리(Predicate Logic) - 과제의 핵심 기반

**기본 개념**
lec05는 술어 논리를 다음처럼 정의:
- 명제를 "객체 + 관계"로 분해
	- 예:
		- "존은 메리를 사랑한다." -> loves(john, mary)
		- "메리가 음식을 좋아한다." -> likes(mary, food)

이런 표현 형식이 과제의 모든 사실(fact)에 쓰인 형태와 동일하다.


## 4. Prolog가 술어 논리를 사용하는 방식
(lec05 + LPN chapter1 내용 기반)

lec05는 Prolog를 다음과 같은 논리적 도구로 설명함:
- 사실(fact): 참으로 간주되는 정보
- 규칙(rule): 조건이 만족되면 결론도 성립
- 쿼리(query): 지식베이스에 질문하기

**Prolog의 매칭 방식: 단순 비교가 아니라 논리적 증명**

과제 P1.1에서 답이 true 또는 false로 나오는 이유는
Prolog가 주어진 사실을 기반으로 [[모더스 포넌스(Modus Ponens) 방식]]으로 추론하기 때문이다.

예를 들어:
```
?- like(mary,food).
```
-> 사실에 존재하므로 true.


## 5. 복합 쿼리(AND)의 의미 - 과제 P1.1의 중요한 부분

lec05와 LPN은 Prolog의 쉽표 ','는 "논리적 AND"라고 설명한다.

과제에서는 다음 쿼리를 물음:
```
likes(john, food), likes(john, mary).
```

해석:
> 존이 음식을 좋아하고 AND 존이 마리를 좋아하는가?

lec05에서 배운 논리 의미 그대로:
- 첫 번째 사실이 존재하지 않으므로 false
- 그래서 AND 전체가 실패

## 6. Prolog에서 변수(var)를 활용한 추론 - 과제 P1.2 적용

lec05 & LPN chapter1에서는 변수 활용을 다음처럼 설명한다.
```
?- woman(X).
```
-> X를 가능한 모든 값으로 대입하여 탐색

과제 P1.2에서도 같은 방식이 사용됨.
```
?- likes(mary, X), likes(john, X).
```
이 쿼리는 논리적으로 다음을 의미함:

> "메리가 좋아하는 X 중에서 존도 좋아하는 X는 무엇인가?"

likes(mary, X)가 true인 X를 모두 탐색한 후 
likes(john, X)도 true인 것을 결과로 한다.

## 7. 가족관계 규칙(P3)의 이론적 근거

lec05에서는 Prolog 규칙이 다음 형태라고 설명함:
```
father(Y,X) :- child(X,Y), male(Y).
```
과제 P3는 이 패턴을 그대로 적용해:

| **과제 규칙**                              | **lec05 일반 규칙**                            |
| -------------------------------------- | ------------------------------------------ |
| mother(M,X) :- parent(X,M), female(M). | father(Y,X) :- child(X,Y), male(Y).        |
| mother(M,X) :- X와 M은 부모이다, M은 여성이다.    | "Y는 X의 아버지" 라는 것은 :- X는 Y의 자식이다., Y는 남성이다. |
-> 구조가 동일: 조건을 AND로 연결하여 새로운 관계를 정의

**넥 연산자**
':-': neck operator / rule operator 라고 부른다. if 연산자라고 생각하면 된다.

```
Head :- Body.
```
if Body is true -> Head is also true.

```
Body → Head
```
와 같은 표기이다.


# 2부 - Prolog의 실행 원리와 과제 P1~P3의 논리적 분석
> "Prolog가 어떻게 생각하고 답을 도출하는가?"를 중심으로 설명

## 1. Prolog의 핵심 작동 원리 정리

lec05 시리즈와 LPN에서는 Prolog의 추론 과정을 다음 세 가지 요소로 설명한다:

### 1. 단일화(Unification) - 변수와 값을 맞추는 과정

단일화는 

> "두 항(term)을 같은 식으로 만들기 위해 값을 대입하는 연산" 이다.

예:
```
likes(mary, X)  ?=  likes(mary, wine)
```
Prolog는 X=wine 을 대입하면 두 식이 같아지므로
단일화 성공 -> 답: X = wine

### 2. 규칙 적용(Modus Ponens) - IF 조건 THEN 결론

예:

```
playsAirGuitar(X) :- listens2music(X).
```
Prolog는 
- listens2music(mia) 가 fact라면
- playsAirGuitar(mia) 도 true로 판단한다.

과제 P3의 mother/father/sibling 규칙도 이 원리와 동일.


### 3. 역방향 추론(Backward Chaining)

Prolog는 목표(goal)를 먼저 보고, 그 goal을 만족하는 규칙을 거꾸로 찾는다.

예:

쿼리:
```
?- mother(M, sophia).
```
Prolog는 다음 규칙을 거꾸로 적용함:
```
mother(M,X) :- parent(X,M), female(M).
```

즉:
1. X = sophia를 대입하고
2. parent(sophia, M)이 사실이 되는 M 찾기
3. 그 M이 female인지 확인

이 과정을 통해 답을 찾는 구조.


## 2. Prolog에서 AND 조건(쉼표)의 의미

쉼표는 논리적으로 AND를 의미함

예:
```
A, B
```
A도 참이고, B도 참이어야 한다.


## 3. 이제 Prolog 원리를 "과제 P1~P3"에 그대로 적용해보자.


### **P1.1 — 단일화 + AND 실패 사례**

  

쿼리:

```
?- likes(john, food), likes(john, mary).
```

Prolog의 추론 과정:

  

#### **✔ Step 1: 첫 번째 목표 해결**

```
likes(john, food)
```

지식베이스 확인:

```
likes(john, wine).
likes(john, mary).
```

→ food를 좋아한다는 사실이 없음 → **false**

  

#### **✔ Step 2: AND의 성질**

  

A, B is true  ↔  둘 다 true

  

여기서는 A가 이미 false → 전체 실패

  

→ **결과: false**

---

### **P1.2 (1) — 공통으로 좋아하는 X 찾기**

  

쿼리:

```
?- likes(mary, X), likes(john, X).
```

Prolog 실행 과정:

  

#### **✔ Step 1: likes(mary, X) 단일화**

  

Mary가 좋아하는 것들:

```
food
wine
```

따라서 Prolog는 두 경우를 하나씩 검사함.

---

#### **✔ Case 1: X = food**

```
likes(john, food)? → false
```

→ AND 조건 실패 → 버림

---

#### **✔ Case 2: X = wine**

```
likes(john, wine)? → true
```

→ AND 성공 → 답: **X = wine**

---

### **P1.2 (2) — “와인을 좋아하는 사람 Y” 찾기**
  
쿼리:

```
?- likes(Y, wine), likes(john, Y).
```

Prolog 실행 과정:

  

#### **✔ Step 1: likes(Y, wine) 단일화**

  

와인을 좋아하는 사람 목록:

```
mary
john
```

---

#### **✔ Case 1: Y = mary**

```
likes(john, mary)? → true
```

→ OK → 정답 후보

---

#### **✔ Case 2: Y = john**

```
likes(john, john)? → false
```

→ 버림

---

#### **✔ 최종 답:**

```
Y = mary
```

---

### **P2 — 가족 관계 질의의 논리 분석**

  

가족 관계 문제는 **단일화 + 변수를 통한 검색** 구조를 그대로 따라감.

---

### **질문 1**

  

**Was George I the parent of Charles I?**

  

쿼리:

```
?- parent(george1, charles1).
```

지식베이스에 해당 fact가 없으므로 → false

---

### **질문 2**

  

**Who was Charles I’s parent?**

  

쿼리:

```
?- parent(X, Charles1).
```

지식베이스 확인:

```
parent(charles2, charles1).
parent(catherine, charles1).
parent(james2, charles1).
```

X = charles2 ;
X = catherine ;
X = james2.

---

### **질문 3**

  

**Who are the children of Charles I?**

  

쿼리:

```
?- parent(charles1, X).
```

매칭되는 값들:

```
parent(charles1, james1).
```

→ 답:

```
X = james1.
```

---

## **P3 — 규칙(rule)의 논리적 해석**

  

lec05에서 배운 규칙 형식:

```
Head :- Body.
```

과제 규칙:

---

### **✔ (1) mother**

```
mother(M,X) :- parent(X,M), female(M).
```

역추론 과정:

1. parent(X, M) 이 참인 M 찾기
    
2. 그 M이 female인지 확인
    
3. 만족하면 M이 X의 엄마다
    

---

### **✔ (2) father**

```
father(F,X) :- parent(X,F), male(F).
```

lec05 예시와 완전히 동일한 구조

---

### **✔ (3) siblings**

```
siblings(X,Y) :- parent(X,P), parent(Y,P), X \== Y.
```

해석:

1. X와 Y의 부모 P가 같고
    
2. X와 Y가 서로 다른 존재라면
    
    → 형제/자매로 판단
    

  

이 규칙 또한 lec05의 “논리적 AND” 개념을 그대로 사용하고 있음.

---

## **2부 요약**

  

✔ Prolog는 **단일화 → 역방향 추론 → 규칙 적용(Modus Ponens)** 을 순서대로 수행한다.

✔ 과제 P1~P3는 이 원리들이 정확하게 반영된 문제들이다.

✔ AND 조건(쉼표)의 의미가 과제의 True/False 결과를 결정하는 핵심이다.

✔ 변수를 통한 검색(likes(mary, X))은 Prolog의 단일화가 어떻게 작동하는지를 보여준다.

✔ 규칙(mother, father, sibling)은 lec05의 “Head :- Body” 형식을 그대로 따른다.



# 3부 - 의미망, 프레임, 술어 논리, 온톨로지, HMM, RDB 비교 정리
과제 P4를 완벽하게 설명하는 이론 정리

이 파트는 다음 흐름으로 구성돼:
1. 의미망(Semantic Network)
2. 프레임(Frame)
3. 술어 논리(Predicate Logic)
4. 온톨로지(Ontology)
5. HMM(Hidden Markov Model)
6. 관계형 데이터베이스(RDB) vs 술어 논리

## 1. 의미망 Semantic Network

lec05-AI-knowledge-representation 기반

### 개념

의미망은 노드와 링크(edge)로 개념 사이의 관계를 표현하는 그래프 구조.

예:
- 노드: dog, animal, mammal
- 링크:
	- dog is-a mamal
	- mammal is-a animal
	- dog has tail

### 장점
- 직관적이고 사람이 이해하기 쉬움
- 상속 표현이 자연스러움
	- dog은 mammal의 속성을 자동으로 상속

### 단점
- 지식이 많아지면 네트워크가 복잡해짐
- 표준 구조가 없어 시스템마다 표현 방식이 다름
- 추론 규칙이 불명확해 큰 규모 시스템에 부적합

## 2. 프레임 Frame

lec05는 프레임을 "객체를 표현하는 구조체(Structure) 또는 클래스(Class)"와 유사하다고 설명함.

### 개념

프레임은 "객체"를 하나의 틀(frame) 안에 표현하며
각 객체는 여러 속성(slot)을 가지며 각 속성은 값(value) 또는 기본값(default)을 가짐.

예: 'Person' 프레임
```
Frame: Person
 - name: "Alice"
 - age: 30
 - gender: female
 - job: engineer
```

### 장점
- 구조화된 정보 표현에 강함
- 상속 가능(Frame -> subframe)
- 기본값(default) 지정 가능
- 객체지향(OOP) 개념과 유사하여 실용적

### 단점
- 관계가 복잡해지면 구조가 무거워짐
- 추론 능력이 제한적
- 의미망처럼 표준화 부족

## 3. 술어 논리 Predicate Logic

과제 2의 P1~P3가 바로 술어 논리를 Prolog로 구현한 것.

### 개념

술어 논리는 지식을 "사실 + 규칙" 형태로 수학적으로 표현하는 논리 체계.


```
parent(james1, charles1).
father(Y, X) :- parent(Y, X), male(Y).
```

### 장점
- 구조화된 논리적 추론이 가능
- 수학적으로 엄밀
- Prolog 등 자동 추론 시스템과 연결됨
- 규칙 기반(reasoning) 지식 표현에 매우 강함

### 단점
- 대규모 지식 구조 표현에는 적합하지 않음
- 절차적 지식 표현이 어려움
- 실제 인간 지식의 애매함(fuzziness) 표현 부족


## 비교: 의미망 / 프레임 / 술어논리
|**항목**|**의미망**|**프레임**|**술어 논리**|
|---|---|---|---|
|구조|그래프|구조체(객체)|논리식(함수형)|
|강점|직관적, 상속|객체 지향적 표현|엄격한 추론 적용|
|약점|확장성 부족|복잡성 증가|자연언어의 모호함 표현 어려움|
|대표 활용|개념 간 관계|지식베이스 구성|AI 추론 시스템|

## 4. 온톨로지 Ontology

온톨로지는 지식의 구조를 정의하는 공식적 모델
-> 의미망 + 프레임 + 술어논리 개념을 모두 확장한 상위 개념

### 개념
- 도메인 안의 개념(Concept)
- 개념 간의 관계(Relation)
- 개체의 속성(Property)
- 제약 조건(Restriction)

등을 체계적으로 정의하는 표준 모델

예: 동물 Ontology(간단 형태)
```
Class: Animal
Class: Mammal subclassOf Animal
Class: Dog subclassOf Mammal

Property: hasLegs (domain: Animal, range: Integer)
Property: hasName (domain: Animal, range: String)
```

### 활용
- 웹 시맨틱
- 지식 그래프
- 의료/생물학 데이터 모델링

## 5. HMM(Hidden Markov Model)

lec07-uncertainty 기반

### 개념

HMM은 숨겨진 상태(hidden state)를 가진 확률 기반 머신러닝 모델

특징:
- 현재 상태는 이전 상태에만 의존(Markov property)
- 출력 값은 확률적으로 나타남

### HMM 구성 요소
1. 숨겨진 상태 집합
2. 관측값 집합
3. 상태전이 확률 $P(s_t | s_{t-1})$
4. 출력 확률 $P(o_t | s_t)$
5. 초기 상태 확률

### 예: 음성 인식
- 숨겨진 상태: 발음되는 음소
- 관측값: 실제 소리 신호
- 출력: 가장 확률이 높은 단어 시퀀스 추론

## 6. RDB vs 술어 논리(Prolog)

### 공통점

둘 다 데이터를 구조적으로 저장하고 질의할 수 있음


### 차이점
|**비교항목**|**RDB**|**술어 논리(Prolog)**|
|---|---|---|
|목적|데이터 저장|지식 표현 + 추론|
|질의 언어|SQL|논리 질의(Query)|
|추론|없음(명시적 검색)|자동 추론(Ontological reasoning)|
|데이터 구조|테이블|Fact + Rule|
|모호함 처리|불가능|논리적으로 가능(규칙 기반)|

### 예로 비교하면

RDB:
```
SELECT parent FROM people WHERE child = 'charles1';
```

Prolog:
```
?- parent(X, charles1).
```

Prolog는 규칙도 자동으로 적용 가능:
```
?- father(X, charles1).
```


[[lec05 + 과제2 문제풀이]]