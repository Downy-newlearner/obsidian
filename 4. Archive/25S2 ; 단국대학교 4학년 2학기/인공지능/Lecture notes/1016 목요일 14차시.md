Lecture materials: lec05-game-tree
## Min-Max 알고리즘



## 알파베타 가지치기 ($\alpha - \beta$ prunning)

알파–베타 가지치기(α–β pruning)는 두 명이 번갈아 최선의 수를 둔다고 가정하는 Min–Max 탐색에서 “결과를 바꾸지 않는” 부분트리를 과감히 건너뛰어 연산량을 줄이는 최적화다. 핵심은 두 개의 경계값을 실시간으로 유지하는 데 있다. **알파(α)** 는 현재까지의 탐색에서 **최대화(MAX) 입장**이 최소한으로 확보한 최선의 점수(=더 커질 수 있는 하한)이고, **베타(β)** 는 **최소화(MIN) 입장**이 허용할 수 있는 최악의 점수(=더 작아질 수 있는 상한)다. 트리를 내려가며 자식 노드를 평가할 때 MAX 노드에서는 α를, MIN 노드에서는 β를 갱신한다. 어떤 지점에서 **α ≥ β**가 성립하면, 그 아래는 위쪽 부모가 이미 더 좋은 대안을 확보했거나 더 나쁜 결과를 강제할 수 있으니, 추가 탐색을 해도 최종 선택이 바뀌지 않는다. 이 순간 해당 가지를 잘라(prune) 시간을 절약한다.

  

직관적인 예를 들어보자. MAX가 한 가지에서 **점수 5(α=5)**​​​​​를 보장받은 상태에서, 다른 가지를 내려가 보니 MIN이 대응만 잘하면 **결과가 3 이하(β≤3)** 로 떨어진다는 사실을 중간에 확인했다. 이 경우 더 내려가서 복잡한 변형·캡처·승격 같은 변화를 모두 조사할 필요가 없다. 어차피 MAX가 이미 확보한 5보다 나아질 가능성이 0이므로 해당 서브트리는 버린다. 반대로 MIN의 입장에서도 어느 지점에서 상대가 **최소 7점(α≥7)** 을 확보한 게 확인되면, 자신의 가지에서 그보다 낮추는 수가 존재하지 않는 한 더 깊은 탐색은 무의미해진다. 이렇게 알파와 베타가 “상대에게 절대 넘기지 않을 문턱값”으로 작동하면서, 탐색은 성능을 해치지 않고도 큰 폭으로 잘려 나간다.

  

성능 면에서 알파–베타는 **해의 최적성(완전 탐색과 동일한 결과)** 을 유지하면서도 실제 연산량을 크게 줄인다. 무작위 순서로 탐색하면 평균적으로 상당한 가지치기가 일어나지만, **좋은 수부터 먼저 살피는 ‘이동 순서(move ordering) 최적화’** 를 결합하면 효과가 극대화된다. 이상적으로는 분기계수 b, 깊이 d인 트리의 탐색 복잡도가 O(b^{d})에서 O(b^{d/2}) 수준으로 떨어질 수 있어 현실적인 시간 내에 더 깊은 수읽기가 가능해진다. 실전 엔진들은 여기에 **트랜스포지션 테이블(중복상태 캐시)**, **반창(Iterative Deepening)**, **쿼아이에선스(국면 안정화)** 같은 기법을 얹어 알파–베타의 컷을 더 자주, 더 이르게 유도한다. 요약하면, 알파–베타 가지치기는 “이미 승부가 난 가지는 보지 않는다”는 원리로, 최소한의 탐색으로 최선의 결정을 보장하는 게임트리 탐색의 표준 가속 장치다.

