**Dialog**
복숭아 여러개가 있다.(모두 똑같은 복숭아이다. 또한 복숭아는 사람 수보다 많다.)
여러명이 한 번에 복숭아 박스에 접근해서 복숭아를 가져가려고 한다면 원하는 복숭아를 가져가지 못한 느린 사람이 있을 수 있다.
그런데 만약 줄을 서서 한 명씩 복숭아를 가져간다면 모든 사람들이 복숭아를 가져갈 수 있다.
하지만 줄을 선다면 속도가 느려진다.
---
p.4
**배운 내용**
CPU 가상화
메모리 가상화
DRAM은 공유하는 것이다.
하지만 한 프로그램이 DRAM을 혼자 사용하는 것 같은 환상을 준다.
  
**이제부터 배울 것**
1. 멀티 스레디드 프로그램
    
    **스레드**
    
    스레드는 제어의 흐름이다.
    
    이 흐름이 마치 실처럼 생겼다고 해서 스레드라는 이름이 붙었다.
    
    **프로세스**
    
    제어의 흐름 하나(하나의 스레드) + 자원
    
    **멀티스레디드 프로세스(멀티 스레디드 프로그램)**
    
    여러 제어의 흐름 + 자원
    
      
    
2. 동시성
    
    공유 자원에는 경쟁 상태가 발생한다.
    
    이는 잘못된 결과를 발생시킨다.
    
    동시성은 공유 데이터 접근을 싱크가 맞도록 하는 방법으로 하도록 집행한다.
    
---
p.5
**스레드를 왜 쓸까?**
**컴퓨팅 자원**
CPU
레지스터, 스케줄러 대상
주소 공간
code, heap, data, stack
파일
  
**컴퓨팅 자원 어떻게 관리하는 모델에는 무엇이 있을까?**
1. **프로세스 모델**
    
    모든 자원을 베타적으로 사용한다.
    
    fork()는 모든 자원을 따로 사용하도록 한다.
    
      
    
2. **스레드 모델**
    
    일부 자원은 베타적으로 사용, 일부 자원은 공유하여 사용한다.
    
    코드, 데이터, 힙과 파일을 공유하여 사용한다.
    
    CPU(레지스터), 스택만 베타적으로 사용한다.
    
    pthread_create()는 CPU, 스택 부분만 새로 만들면 된다. 그래서 쓰레드를 생성하는 것이 프로세스를 생성하는 것보다 빠르다.
    
      
    
**스레드의 장점**
**빠르게 만들 수 있다.**
프로세스는 무겁고, 스레드는 가볍다.
  
**병렬성**
Devide and Conquer
큰 문제를 여러개의 작은 문제로 나눠 스레드에 할당한다음 해결 후 합친다.
  
**Overlap Processing**
서버가 받고 처리하고 응답주고를 한 번에 하지 않고
스레드를 이용하여 각 부분을 오버랩할 수 있다.
  
**Data Sharing**
멀티코어 환경이 되면서 한 번에 많은 스레드를 이용하여 문제를 쪼개어 빠르게 해결할 수 있다는 맥락에서 스레드는 장점을 가진다.
하지만 스레드 모델은 한 스레드가 죽으면 모든 연결된 스레드가 죽는다.
만약 고장이 날 때를 대비하는 것이 더 중요한 작업에서는 프로세스를 사용하는 것이 유리하다.
  
**스레드 관리**
**주소 공간에 여러개의 스택 사용**
스택은 스레드의 로컬 스토리지이다.
**스케줄링 엔티티**
스레드의 상태와 전환
각 스레드는 고유의 스케줄링 우선순위가 있다.
스레드 레벨에서 컨텍스트 스위치를 한다.
TCB(Thread Control Block)
스레드의 구체적인 정보를 관리함
---
p. 8 Ch.26.2, 26.3
**스레드 API**
코드는 사용자가 보기와 다른 순서로 스케줄링 될 수 있다.
스케줄 정책이 어떻게 되냐에 따라 다양한 스케줄링 결과가 나올 수 있다.
(태블릿 필기 참고)
---
p. 12
**왜 10페이지 코드가 예상처럼 실행되지 않을까?**
1. High level viewpoint
    
    ```C++
    for(i=0;i<1e7;i++){
    	counter = counter + 1;
    }
    ```
    
2. CPU level viewpoint
    
    ![[Source/Untitled 43.png|Untitled 43.png]]
    
    3줄의 어셈블러 코드가 나온다.
    
3. Scheduling viewpoint
    
    타이머 인터럽트는 비동기적이다.
    
    3줄의 어셈블러 코드 단위로 스케줄링을 하는 것이 아니라 타이머를 기준으로 스케줄링하기때문에 3줄을 수행하다가 끊기고 컨텍스트 스위치가 일어날 수 있다.
    
      
    
**정리**
두 개의 스레드가 공유 자원에 접근하면 경쟁 상태가 발생할 수 있는데 스케줄링이 제어가 안되면 잘못된 결과가 나올 수 있다.
해결 방법은 스케줄링을 제어해야한다.
3개의 어셈블러 코드를 실행 중에 끼어들지 못하도록 하는 것이다.
코드 중에 경쟁상태가 발생하는 부분을 임계 영역(critical section)이라고 하는데 이 임계영역에는 한 번에 한 스레드만 들어오도록 해야한다.
그것이 상호 배제(mutual exclusion)이다.
예를 들어 1차선 터널이 있다고 가정하자 이것이 임계 영역이다.
교통 정리를 하는 방법은 all or nothing이다. 한 쪽에서 통행을 하는 동안 다른 차들이 들어올 수 없도록 하면 된다.
이를 통제하는 터널 입구 신호등이 상호 배제의 역할을 한다.
  
**핵심 문제: 제어 안되는 스케줄**
제어 안되는 스케줄은 서로 다른 스케줄 경우 마다 다른 결과를 만들 수 있으므로 스케줄링 제어가 필요하다
해결 방법
**원자성**: Do all or nothing
**상호 배제**: 임계 영역에 한 스레드만 허용
  
### 동시성의 두 가지 이슈
1. 상호 배제
2. 동기화
  
---
## Ch.27
---
  
**동시성 문제는 2개로 세분화된다.**
1. 상호배제
    
    락이 상호배제를 이룰 수 있다.
    
2. 동기화
    
    조건변수는 동기화를 위한 것이다.
    
    조건변수는 자식 프로세스가 완료됐는지, 버퍼가 가득 찼는지 등을 표시하는 변수이다.
    
    동기화는 여러 프로세스나 스레드가 자원을 공유하며 발생할 수 있는 충돌을 방지하기 위해 작업 실행 순서를 조절하는 과정이다.
    
  
**스레드 구분**
유저 레벨 스레드
운영체제 커널이 아닌 앱 수준에서 스레드를 관리한다.
스레드의 생성, 스케줄링, 관리 등 모든 작업은 앱에 의해 수행되며, 운영체제는 이러한 스레드의 존재를 인식하지 못한다.
커널 레벨 스레드
운영체제 커널이 직접 스레드를 관리한다.
운영체제가 스레드의 생성, 스케줄링, 관리 등을 담당하며, 스레드는 커널 내부의 자원으로 취급된다.
→ 둘은 멀티스레딩을 구현하는 두 가지 기본적인 방법이다.
  
**스레드 라이브러리**
pthread, Windows thread, Java thread
우리는 pthread를 사용한다.
  
**pthread**
POSIX 스레드의 약자이다.
IEEE에서 개발한 POSIX 표준이다.
다중 스레딩을 지원하기 위해 만들어졌다.
  
### pthread 메소드
![[Source/Untitled 1 30.png|Untitled 1 30.png]]
### **1. pthread_create()**
```C++
\#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
```
스레드 생성하는 메소드이다.
  
**인자**
1. `**thread**`**: 새로 생성된 스레드의 식별자를 저장할** `**pthread_t**` **타입의 포인터입니다.**
2. `**attr**`**: 스레드 특성을 지정하는** `**pthread_attr_t**` **타입의 포인터입니다. 기본 스레드 특성을 사용하려면 NULL을 지정합니다.**
3. `**start_routine**`**: 새 스레드가 실행할 함수를 가리키는 포인터입니다. 이 함수는** `**void ***`**를 매개변수로 받고** `**void ***`**를 반환합니다.**
4. `**arg**`**:** `**start_routine**`**에 전달될 인자입니다. 함수에 전달할 데이터의 주소를 지정할 수 있습니다.**
  
**반환 값**
성공 시, 0을 반환한다.
실패 시, 오류 코드를 반환한다.
### **2. pthread_join()**
```C++
\#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
```
이 함수의 주된 목적은 스레드가 종료될 때까지 기다린 후, 해당 스레드의 종료 상태를 회수하는 것입니다. 이를 통해 스레드 간 동기화를 달성할 수 있습니다.
리턴값을 전달받을 수 있다.(malloc으로 받아야한다.)
지역변수로 받으면 스택이 끝나면서 사라지므로 오류가 발생한다.
- 스레드의 리턴 값을 스택에서 할당하면 문제가 발생하는 이유
    
    스레드에서 반환 값을 스택에 할당하는 것이 문제가 되는 이유는 스택 메모리가 스레드마다 독립적으로 존재하기 때문입니다. 각 스레드는 자신만의 스택 메모리를 가지고 있으며, 이 메모리 공간은 스레드가 종료되면 해제됩니다. 따라서, 스레드가 스택에 할당된 값을 반환 값으로 사용하려고 할 때 다음과 같은 문제가 발생할 수 있습니다:
    
    1. **스택 메모리는 임시 저장 공간**: 스택 메모리는 함수 호출과 지역 변수 저장에 주로 사용되며, 함수가 반환되면 해당 함수의 스택 프레임은 스택에서 제거됩니다. 따라서, 스레드 함수 내에서 스택에 할당된 데이터를 리턴 값으로 사용하면, 그 데이터는 스레드가 종료되는 순간 더 이상 유효하지 않게 됩니다.
    2. **스레드의 생명 주기**: 스레드가 종료되면, 해당 스레드의 스택 메모리도 해제됩니다. 만약 다른 스레드나 메인 프로세스가 이 스레드의 스택에 할당된 값을 참조하려고 하면, 그 값은 이미 해제된 메모리 영역을 가리키게 되어 정상적인 접근이 불가능해집니다. 이는 메모리 접근 오류나 예측 불가능한 동작을 초래할 수 있습니다.
    
    따라서, 스레드의 리턴 값을 전달할 때는 스택 메모리를 사용하는 것보다 다음과 같은 방법이 더 안전합니다:
    
    - **힙 메모리 사용**: 힙 메모리에 값을 할당하고, 그 메모리 주소를 반환합니다. 힙에 할당된 메모리는 명시적으로 해제하기 전까지 유지되므로, 스레드가 종료된 후에도 다른 스레드나 프로세스에서 안전하게 접근할 수 있습니다. 단, 사용 후에는 반드시 메모리를 해제해야 메모리 누수를 방지할 수 있습니다.
    - **전역 변수 또는 스레드 간 공유 메모리 사용**: 스레드 간에 공유되는 메모리 영역이나 전역 변수에 값을 저장하여 사용합니다. 이 방법 역시 스레드의 생명 주기와 독립적으로 값을 유지할 수 있으나, 동시 접근을 관리하기 위한 동기화 작업이 필요할 수 있습니다.
    
    스레드의 리턴 값으로 스택 메모리에 할당된 값을 사용하는 것은 위와 같은 이유로 권장되지 않습니다.
    
  
**인자**
1. 기다릴 대상 스레드의 식별자
2. 기다릴 대상 스레드의 종료 코드를 저장할 포인터의 주소이다.
    
    스레드가 pthread_exit()을 통해 종료될 때 전달된 값이 여기에 저장된다.(NULL은 리턴을 신경쓰지 말라는 뜻이다.)
    
  
**반환 값**
함수가 성공적으로 수행되면 0을 반환한다.
오류가 발생한 경우, 오류 번호를 반환한다.
  
### **3. pthread_mutex_lock() / pthread_mutex_unlock()**
뮤텍스를 사용하여 상호 배제를 구현한다.
  
```C++
\#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
```
`**mutex**`**: 잠그려고 하는 뮤텍스에 대한 포인터입니다.**
  
**반환 값:**
**성공적으로 뮤텍스를 잠갔을 경우** `**0**`**을 반환합니다.**
**에러가 발생했을 경우 에러 코드를 반환합니다.**
  
```C++
\#include <pthread.h>
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
`**mutex**`**: 해제하려고 하는 뮤텍스에 대한 포인터입니다.**
  
**반환 값:**
**성공적으로 뮤텍스를 해제했을 경우** `**0**`**을 반환합니다.**
**에러가 발생했을 경우 에러 코드를 반환합니다.**
  
### 4. pthread_cond_wait()
`pthread_cond_wait` 함수는 쓰레드가 조건 변수에 대해 "대기(waiting)" 상태로 들어가게 합니다. 이 함수는 쓰레드가 특정 조건이 충족될 때까지 대기하게 하고 싶을 때 사용됩니다. 조건 변수는 일반적으로 공유 데이터의 상태 변경을 모니터링하는데 사용됩니다.
  
```C++
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
```
`cond`: 대기할 조건 변수의 주소입니다.
`mutex`: 조건 변수와 함께 사용될 뮤텍스의 주소입니다. 이 뮤텍스는 `pthread_cond_wait`를 호출하기 전에 잠겨(lock) 있어야 하며, 함수가 호출되면 자동으로 잠금이 해제됩니다. 함수가 반환될 때, 뮤텍스는 다시 자동으로 잠깁니다.
  
### 작동 원리
쓰레드가 조건 변수에 대해 대기하기 전에, 관련 뮤텍스를 잠급니다.
`pthread_cond_wait` 함수를 호출하여 조건 변수에 대해 대기합니다.
이 함수 호출은 뮤텍스를 자동으로 잠금 해제하고, 쓰레드를 대기 상태로 전환합니다.
다른 쓰레드가 조건 변수를 신호(signal)하면, 대기 중인 쓰레드 중 하나(또는 모두)가 깨어납니다.
깨어난 쓰레드는 다시 뮤텍스를 잠그고, `pthread_cond_wait` 함수를 반환합니다.
  
조건 변수를 사용해서 스레드끼리 wait, signal 신호를 주고받는다.
wait, signal을 하기 위해서는 lock을 잡고 해야만 한다.
wait는 signal이 올때까지 기다린다.
  
### 5. pthread_cond_signal()
`pthread_cond_signal()` 함수는 POSIX 스레드 (pthreads) 라이브러리에서 제공하는 조건 변수를 사용하여 스레드 간의 동기화를 위한 기능 중 하나입니다.
조건 변수는 특정 조건이 충족될 때까지 하나 이상의 스레드가 대기하도록 하고, 그 조건이 충족될 때 스레드를 깨우는 메커니즘을 제공합니다.
`pthread_cond_signal()` 함수의 주요 목적은 대기 중인 스레드들 중 하나를 깨우는 것입니다. 이 함수를 호출하면, 조건 변수에 대해 대기 중인 스레드들 중에서 하나가 선택되어 조건 대기 상태에서 벗어나도록 신호를 보냅니다. 이렇게 해서 해당 스레드는 실행을 계속할 수 있게 됩니다.
  
1. 대기 중인 스레드는 `pthread_cond_wait()` 또는 `pthread_cond_timedwait()` 함수를 사용하여 조건 변수에 대해 대기합니다.
2. 다른 스레드가 조건이 충족되었음을 판단하면 `pthread_cond_signal()`을 호출하여 대기 중인 스레드 중 하나에게 신호를 보냅니다.
3. 신호를 받은 스레드는 조건 대기 상태에서 벗어나 실행을 계속합니다.
  
중요한 점은 `pthread_cond_signal()` 호출이 반드시 조건을 변경하는 연산 후에 이루어져야 한다는 것입니다.
또한, 조건 변수를 사용할 때는 항상 뮤텍스와 함께 사용되어야 하며, `pthread_cond_wait()` 함수는 호출될 때 해당 뮤텍스를 자동으로 잠금 해제하고, 대기 상태에서 깨어날 때 다시 잠급니다.
`pthread_cond_signal()`을 사용함으로써, 리소스의 효율적인 사용과 스레드 간의 정확한 동기화를 달성할 수 있습니다.
하지만, 여러 스레드가 동시에 깨어나야 하는 경우에는 `pthread_cond_broadcast()` 함수를 사용하여 모든 대기 중인 스레드를 깨우는 것이 더 적합할 수 있습니다.
### **pthread_mutex_t**
`pthread_mutex_t`는 뮤텍스(mutex)를 위한 데이터 타입으로, 상호 배제(mutual exclusion)를 보장합니다. 뮤텍스는 한 시점에 단 하나의 쓰레드만 특정 섹션의 코드(주로 공유 자원에 대한 접근을 포함하는)를 실행할 수 있도록 하는 락(lock)입니다. `pthread_mutex_lock()`과 `pthread_mutex_unlock()` 함수를 사용하여 뮤텍스를 잠그고 해제할 수 있습니다. 이는 여러 쓰레드가 동시에 공유 자원에 접근하는 것을 방지하여 데이터의 일관성과 안정성을 보장합니다.
락 → 상호배제
### **pthread_cond_t**
`pthread_cond_t`는 조건 변수(condition variable)를 위한 데이터 타입으로, 쓰레드 간의 신호(signal) 기반 동기화를 가능하게 합니다.
조건 변수를 사용하면 쓰레드가 특정 조건이 충족될 때까지 기다리게 하거나, 조건이 충족될 때 쓰레드를 깨울 수 있습니다. `pthread_cond_wait()`, `pthread_cond_signal()`, `pthread_cond_broadcast()` 함수를 사용하여 조건 변수와 관련된 작업을 수행합니다.
예를 들어, `pthread_cond_wait()` 함수는 조건이 만족될 때까지 쓰레드를 대기 상태로 만들고, `pthread_cond_signal()` 함수는 조건이 충족되었을 때 하나의 대기중인 쓰레드를 깨우는 데 사용됩니다.
뮤텍스와 조건 변수를 함께 사용하면 복잡한 동기화 문제를 해결할 수 있으며, 멀티 쓰레딩 프로그램에서 데이터의 일관성을 유지하고 데드락(deadlock)이나 레이스 컨디션(race condition) 같은 문제를 방지하는 데 중요한 역할을 합니다.
조건 변수 → 동기