## p.48
### 1. 이 페이지에서 다루는 것은 무엇인지 짧게 요약
이 페이지는 파일 시스템 내의 디렉토리 구조와 빈 공간 관리에 대해 설명합니다.
### 2. 페이지 내용 번역 및 설명
### 40.4 Directory Organization / 40.5 Free Space Management
### Directory
- **사용자 관점:** 동일한 위치에 파일을 포함하는 것.
- **시스템 관점:** `<파일 이름, inode 번호>` 쌍들의 목록.
- **빠른 검색을 위해:** 파일 이름 길이와 기록 길이 (남은 공간 포함한 전체 바이트)를 추가로 저장합니다.
    
    예시:
    
    ```Plain
    inum | reclen | strlen | name
     5   |   4    |    2   |  .
     2   |   4    |    3   |  ..
    12   |   4    |    4   | foo
    13   |   4    |    4   | bar
    24   |   8    |    7   | foobar
    ```
    
- 더 복잡한 디렉토리 구조도 사용할 수 있습니다 (예: XFS의 B-트리).
### Free Space
- **비트맵:** 블록(또는 inode)마다 하나의 비트로, 사용 가능한지 여부 표시.
- **대안 접근법:** 자유 목록(free-list), 트리 등.
- **미리 할당 (Pre-allocation):** 빈 디스크 블록을 일괄 할당하여 오버헤드를 줄이고 연속된 할당 가능.
    
    ```Plain
    비트맵 예시:
    Bit Map: 1 1 0 0 1 0 1 1 ...
    
    메모리 예시:
    Memory:
    +---+---+---+---+---+---+
    |   |   |   |   |   |   |
    +---+---+---+---+---+---+
    ```
    
### 3. 페이지 내용 요약
디렉토리는 파일 이름과 아이노드 번호 쌍을 저장하는 구조로, 빠른 검색을 위해 이름 길이와 기록 길이를 포함할 수 있습니다. 빈 공간 관리는 비트맵을 통해 블록의 사용 여부를 추적하며, 미리 할당(pre-allocation) 접근법을 통해 연속된 공간 할당과 오버헤드를 줄일 수 있습니다. 더 복잡한 자료구조(ex. B-트리)도 디렉토리 관리에 활용될 수 있습니다.
## p.49~50
### 1. 이 페이지에서 다루는 것은 무엇인지 짧게 요약
이 페이지는 파일 시스템에서 파일을 읽고 쓰는 경로에 대한 설명입니다. 파일의 디스크로부터 읽기와 디스크로의 쓰기 동작에 대한 시간 순서적 관계를 다루고 있습니다.
### 2. 페이지 내용 번역 및 간단한 설명
### 페이지 1: 디스크로부터 파일 읽기
- **디스크로부터 파일 읽기**
    - 크기가 12KB인 파일 “/foo/bar”를 열고, 데이터를 읽고, 파일을 닫는다.
    - 시간 순서도
        - open(bar): 디렉토리 트리를 탐색하여 파일 디스크립터(fd)와 아이노드를 연결
        - read: 현재 오프셋을 찾고 디스크 블록 위치를 찾아 아이노드를 사용하여 읽는다. 아이노드의 마지막 접근 시간을 업데이트.
        - close: OS에서 파일 디스크립터와 관련 데이터 구조를 해제, 디스크에는 아무런 작업이 없음.
    - 주의: bar의 아이노드를 반복적으로 읽어들임 ➔ 캐싱 제안
### 페이지 내용 요약
페이지 1에서는 파일을 디스크로부터 읽는 과정을 그림과 함께 시간 순서대로 설명하고 있고, 파일을 여는 과정, 데이터를 읽는 과정 및 파일을 닫는 과정을 설명하고 있습니다. 또한, 반복적으로 아이노드를 읽어야 하는 문제를 캐싱을 통해 해결할 수 있다고 제안합니다.
### 페이지 2: 디스크로의 파일 쓰기
- **디스크로의 파일 쓰기**
    - 크기가 12KB인 파일 “/foo/bar”를 생성하고, 데이터를 쓰고, 파일을 닫는다.
    - 시간 순서도
        - open: 새로운 아이노드를 생성하고 i-비트맵을 업데이트, foo의 데이터 블록에 새로운 엔트리 삽입 (파일 생성만으로도 10개의 I/O 동작 필요)
        - write: 데이터 비트맵 읽기/업데이트, 아이노드 읽기/업데이트, 실제 사용자 데이터 쓰기 등 각 쓰기 동작마다 5개의 I/O 필요
### 페이지 내용 요약
페이지 2에서는 파일을 디스크에 쓰는 과정을 그림과 함께 시간 순서도로 설명하고 있습니다. 파일을 여는 것에서부터 데이터를 쓰고 파일을 닫는 과정까지를 다루고 있으며, 각 단계마다 필요한 I/O 동작을 구체적으로 설명합니다.
## p.51~52
### 1. 이 페이지에서 다루는 것은 무엇인지 짧게 요약
이 페이지는 파일 시스템에서 캐싱 및 버퍼링 기술을 이용해 I/O 성능을 최적화하는 방법을 다룹니다. 디스크의 느린 속도를 개선하기 위한 캐싱과 지연된 쓰기에 대한 솔루션을 설명합니다.
### 2. 페이지 내용 번역 및 간단한 설명
### 페이지 1: 캐싱
- **문제점**
    - 디스크 속도가 너무 느림.
    - "심지어 간단한 파일 시스템 작업조차도 예외적으로 많은 수의 I/O 작업을 필요로 한다. 그러면 파일 시스템은 이러한 많은 I/O 작업의 높은 비용을 줄이기 위해 무엇을 할 수 있을까?"
- **솔루션**
    - **캐싱**
        - 디렉터리(예: 아이노드, 데이터, 현재 디렉터리 등) 캐시를 DRAM에 저장
        - 자주 사용하는 파일의 아이노드와 데이터를 DRAM에 캐시
        - 관리: LRU (Least Recently Used) 교체 정책 및 동적 캐시 크기 관리
    - **다이어그램 설명**
        - CPU와 메모리 간에 페이지 캐시를 통해 읽기/쓰기 데이터가 고속으로 처리됩니다. 페이지 캐시된 데이터는 나중에 필요한 경우 메모리를 통해 스토리지로 저장됩니다.
### 페이지 내용 요약
첫 번째 페이지는 디스크의 느린 속도를 개선하기 위해 캐싱을 도입하는 방법을 다룹니다. 주로 디렉터리와 자주 사용되는 데이터 파일을 DRAM에 저장하며, LRU 교체 정책을 이용한 관리 방식을 설명합니다. 다이어그램을 통해 페이지 캐시가 어떻게 작동하는지 시각적으로 설명하고 있습니다.
### 페이지 2: 버퍼링
- **솔루션**
    - **쓰기 버퍼링 (지연된 쓰기)**
        - 여러 번의 쓰기를 하나로 통합 (예: d-비트맵)
        - 여러 번의 쓰기를 스케줄링하여 탐색 오버헤드를 줄이기 (예: bar 데이터)
        - 쓰기 방지: 예를 들어, 임시 파일 (즉시 생성 및 삭제)
        - 우려 사항: 전력 장애 또는 충돌로 인한 데이터 손실 ➔ `fsync()` 또는 직접 I/O 사용
    - **다이어그램 설명**
        - 파일 생성 시 여러 번 쓰기 동작이 발생함을 시각적으로 보여줍니다. 지연된 쓰기 기법을 사용하면 여러 쓰기 동작을 하나로 통합하여 효율성을 높일 수 있음을 강조합니다.
### 페이지 내용 요약
두 번째 페이지는 쓰기 버퍼링, 특히 지연된 쓰기의 원리를 설명합니다. 여러 번의 쓰기를 하나로 통합하고, 다수의 쓰기를 스케줄링하여 탐색 오버헤드를 줄이며, 임시 파일과 같은 쓰기를 방지하는 방법을 제시합니다. 또한, 데이터 손실을 방지하기 위한 `fsync()`나 직접 I/O의 사용을 제안하여 데이터의 안전성을 강조합니다.
### 3. 페이지 내용 요약
이 페이지는 파일 시스템의 효율적인 I/O 성능을 위해 캐싱과 버퍼링 기술에 대해 논의합니다. 캐싱에서는 DRAM을 이용한 디렉터리와 데이터 파일의 저장, LRU 교체 정책을 설명하고, 버퍼링에서는 지연된 쓰기와 데이터 손실 방지 기술을 다루며 다이어그램을 통해 이러한 개념들을 구체적으로 설명하고 있습니다.