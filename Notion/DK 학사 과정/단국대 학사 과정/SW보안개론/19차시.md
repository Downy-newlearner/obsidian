## Array Operations
---
## Data type, Array operations, Byte ordering
---
p. 5
공격에 많이 사용되는 것은 배열이다.
기본적인 데이터 타입은 인접 메모리 접근이 어렵지만 배열은 망가지면 인접 메모리에 접근이 가능하다.
---
32비트에서는 메모리공간이 작아서 인접한 주소에 배열을 따닥따닥 할당하지만, 64비트에서는 각 배열의 끝에 여유 공간을 함께 할당한다.
그래서 64비트가 더 안전하다.
  
스택보호기법이 적용되면 먼저 할당되는 배열이 낮은 주소에 할당되고, 나중에 할당되는 배열이 높은 주소에 할당된다.
스택보호기법이 적용되지 않으면 먼저 할당되는 배열이 높은 주소에 할당한다.
---
사용자가 할당한 적 없는 주소 공간에 접근하면 더미값을 리턴하거나, Segmentation Fault를 발생시킨다.
커널 영역을 접근하게 되면 Segmentation Fault가 발생한다.
또는 해당 주소가 null이라면 SF가 발생한다.
→항상 더미값을 리턴하는 것은 아니다.
---
p.14
a[-1]처럼 인덱스에 signed 정수값을 사용하지 않는다.
그래서 사실 이것은 없는 공격이다.
만약 스택의 보호기법이 적용되지 않는다면 a[12]로 k에 접근할 수 있다.
---
p.16
gets()함수는 개행문자를 만날 때까지 읽어들이는데, 버퍼의 크기를 검사하지않아서 버퍼오버플로우가 발생할 수 있다.
  
스택
argument
return address
saved EBP
local variable
  
2,3번째 예시는 saved EBP가 망가져서 Segmentation Fault가 발생한 것이다.
---
p. 17
공격을 제대로 하려면 byte ordering이 중요하다.
RSA → 1024비트가 넘는다. → 이 큰 데이터를 어떻게 저장할 것인가? → 이것이 바이트 오더링이다.
  
- Little Endian
    
    - 낮은 비트 데이터를 높은 주소에 할당
    - Intel x86
    
      
    
- Big Endian
    - 높은 비트 데이터를 높은 주소에 할당
    - PowerPC, SPARC
---
## Simple Buffer Overflows
---
p. 20
대표적인 공격
libc(리버시)
메인함수로 리턴이 아니라. 시스템 콜로 리턴하게 만든다. → 임의 프로그램 실행 가능
---
p. 21
버퍼를 넘치게 해 cookie값을 바꿀 수 있었다.