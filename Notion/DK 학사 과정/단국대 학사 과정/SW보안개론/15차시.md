## Examples of Program Bugs
---
p.4
스택 보호기법 중 스택 카나리에 대해서 알아보기⚠️
  
---
p.5
64bit 컴퓨터라는 것은 데이터, 주소 버스의 사이즈가 64bit라는 것이고, (범용)레지스터의 크기가 64bit라는 것이다.
  
**레지스터 이름**
32bit 컴퓨터에서는
EAX, ECX 등
64bit 컴퓨터에서는
RAX, RCX 등
  
**형식 지정자**
부호가 있는 정수 → %d
부호가 없는 정수 → %u
부호 없는 정수를 16진수로 → %x
  
**<limits.h>헤더파일에 선언되어있는 변수**
CHAR_MIN
char의 최솟값(-127)
1byte
CHAR_MAX
char의 최댓값(128)
1byte
UCHAR_MAX
unsigned char의 최댓값(255)
1byte
  
  
![[Source/Untitled 61.png|Untitled 61.png]]
![[Source/Untitled 1 42.png|Untitled 1 42.png]]
```C++
printf("%10d, %x, %10u \n",CHAR_MIN,CHAR_MIN,CHAR_MIN);
// -128, ffffff80, 4294967168
```
%d 형식 지정자는 정수를 부호 있는 형태로 출력한다.
CHAR_MIN이 -128인 경우, 10자리에 맞춰 공백을 앞에 붙여 출력하므로
‘ -128’이 된다.
  
%x 형식 지정자는 부호 없는 정수를 16진수로 출력한다.
그러나 -128같이 부호 있는 값을 %x와 같이 부호 없는 형식으로 출력하려고 하면, 해당 부호 있는 값은 먼저 부호 없는 형식으로 암묵적으로 변환된다.
-128은 2의 보수 표현법에서 1000 0000으로 표현되므로 8비트인 char로 인해서 80이 될 것 같지만 그렇지 않다.
%x에 의해 출력 명령을 받으면 이 값은 먼저 해당 데이터 타입보다 더 큰 int 타입으로 확장되어 처리된다.(int로의 승격이 가변 인수 함수에서 자동으로 발생하는 것이다.)
그래서 -128은 내부적으로 int로 확장되는데 높은 비트들이 1로 채워지는 ‘부호 확장’ 과정을 거친다.(부호가 없는 128의 경우 ‘0확장’이 발생한다.)
-128 = 1111 1111 1111 1111 1111 1111 1000 0000 = FFFFFF80
요약하면 %x는 인수를 부호 없는 정수로 해석하기 때문에, 확장된 32비트값 ‘FFFFFF80’이 출력된다.
- 요약
    
    자료형 변환이나 명령 처리에서 작은 자료형이 `printf` 같은 가변 인자 함수에 전달될 때, 자동으로 더 큰 자료형으로 승격(promotion)되는 규칙이 적용된다는 점이 중요합니다.
    
    - **128의 경우**: `signed char` 형에서 `128`은 8비트 이진수 `10000000`으로 표현됩니다. `%x`를 사용하여 출력하려고 하면, 우선 `int`형으로 확장되고, `int`로 확장될 때 부호를 유지하기 위해 부호 확장(sign extension)이 발생하여, 확장된 모든 상위 비트가 1로 채워집니다. 결과적으로, 32비트 시스템에서는 `FFFFFF80`이 됩니다.
    - **128의 경우**: `unsigned char`나 `signed int` 등에서의 128의 이진 표현은 `00000000 00000000 00000000 10000000`입니다(32비트 `int`를 가정할 때). `%x`로 출력 시, 간단히 `80`으로 출력됩니다.
    
    요약하자면, C 언어에서 `%x` 형식 지정자를 사용할 때는 부호 있는 정수든 부호 없는 정수든 간에 먼저 `int`로 승격되어 처리되고, `%x`는 해당 정수를 부호 없는 16진수로 출력합니다. `-128`이 `FFFFFF80`으로, `128`이 `80`으로 출력되는 이유는 이러한 자료형의 승격과 부호 확장 또는 0 확장 과정 때문입니다.
    
  
%u 형식 지정자는 부호 없는 10진 정수를 출력한다.
원래 부호가 있는 CHAR_MIN(-128)이 부호 없는 값으로 취급될 때, 같은 메모리 표현을 가지고 있지만 해석 방식이 달라지는 일이 벌어진다.
그래서 0xFFFFFF80이 부호 없는 정수로 해석되어 ‘4294967168’이 출력된다.
  
```C++
printf("%10d, %x, %10u \n",CHAR_MAX,CHAR_MAX,CHAR_MAX);
// 127, 7F, 127
```
  
**1의 보수와 2의 보수**
1의 보수는 주어진 이진수를 역전
2의 보수는 1의 보수에서 1 더함
  
%x은 4byte인데 CHAR_MIN은 1byte이다.
이렇게 출력하면 바이트가 확장되어 예상치 않은 결과가 나올 수 있다.
%d가 아닌 %hd을 사용하면 2byte를 출력할 수 있다.
%hhd는 1byte를 출력할 수 있다.
  
5페이지 직접 실행해보기 ⚠️
형식지정자 확실히 파악하기