## 선 결론
1 0 1
2 0
2 0
1 1 0x401276
1 2 0
1 3 0
3 3
플래그 출력 완
---
  
`double free`는 동일한 메모리 블록을 두 번 해제하여 메모리 할당 상태를 교란하는 취약점입니다. 이러한 상태에서 배열의 0번 인덱스가 무엇을 가리키는지 이해하기 위해서는 `swc_free` 함수가 어떤 동작을 수행하는지 살펴봐야 합니다.
```C
void swc_free(void *addr){
    if(addr == NULL){
        return;
    }

    addr = chunk_at_offset(addr, -METADATA_SIZE);
    struct alloc_chunk *chunk = (struct alloc_chunk*)addr;

    int index = (chunk->size / 8) - 1;
    insert_freebin(chunk, index);
}
```
이 함수는 메모리를 해제할 때, 메모리 블록의 주소를 가지고 프리 리스트(freebin)에 삽입합니다.
### 메모리 할당 과정 (요약):
1. `swc_alloc` 메모리 할당
2. `swc_free` 메모리 해제 및 freebin에 삽입
### 상세 설명:
`double free`를 발생시키는 과정에서 배열의 0번 인덱스가 실제로 무엇을 가리키는지 이해하기 위해 단계적으로 해보겠습니다.
1. **노트를 작성 및 할당**:
    
    ```Plain
    
    1 0 1
    
    ```
    
    - 노트 0번 인덱스에 1 바이트 할당 (더 큰 버퍼로 할당됨).
2. **노트 0번 삭제 (첫 번째 해제)**:
    
    ```Plain
    
    2 0
    
    ```
    
    - 노트 0번 인덱스 메모리가 해제되고 freebin에 추가됨.
3. **노트 0번 다시 삭제 (두 번째 해제 -** `**double free**` **발생)**:
    
    ```Plain
    
    2 0
    
    ```
    
    - 이미 해제된 메모리 블록을 다시 해제하여 freebin에 중복되어 추가됨.
이 시점에서 배열의 0번 인덱스는 첫 번째 해제 후 freebin에 추가된 메모리 블록을 다시 가리키고 있으며, 두 번째 해제로 인해 동일한 메모리 블록 주소가 freebin에 다시 추가됩니다.
1. **노트 1번에 특정 주소로 노트 재할당 (조작된 메모리)**:
    
    ```Plain
    
    1 1 0x401276
    
    ```
    
    - 노트 1번 인덱스에 할당된 메모리 주소를 `0x401276`으로 재설정 (조작 목적).
2. **임의 데이터로 노트 재작성**:
    
    ```Plain
    
    1 2 0
    
    1 3 0
    
    ```
    
3. **플래그 함수 호출**:
    
    ```Plain
    
    3 3
    
    ```
    
### 메모리 상태 분석
1. `malloc`으로 1 바이트 요청되어 노트 0에 할당된 메모리 블록 주소가 할당됨.
2. 0번 인덱스 해제 때 주소 `freebin`에 삽입 (중복해제 발생).
3. 두 번째 해제 시 동일한 메모리 블록 주소가 `freebin`에 재삽입됨.
    
    [[여기서 동일한 메모리 블록 주소란]]
    
4. `0x401276` 주소로 노트 1번에 재할당:
    - 이 조작은 특정 주소로 재할당이 이루어지며, freebin 상태 조작의 효과를 나타냄.
결과적으로 `double free` 이후 배열의 0번 인덱스는 무효화된 상태에서 freebin에 두 번 중복 삽입됩니다.
이 분석의 결과로, 터미널 명령어 시퀀스에 따른 움직임 및 메모리 접근을 통해 `print_flag`의 오작동 유도, fd == -1 할당 보장 행위가 도출될 수 있습니다.
---