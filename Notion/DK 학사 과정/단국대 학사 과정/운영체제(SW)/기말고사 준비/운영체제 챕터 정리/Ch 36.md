---
LN: LN.6
---
## 줄글 요약📰
이 챕터는 IO 디바이스에 관한 내용이다.
  
1️⃣ **표준 디바이스와 디바이스가 CPU와의 프로토콜**
표준 디바이스는 내부적으로 컨트롤러, 스페셜 칩들, 그리고 펌웨어를 가진다. 이런 디바이스가 CPU와 정보를 주고받을 때 프로토콜이라는 규약을 통한다. (이 프로토콜은 컨트롤러가 수행한다.)
  
프로토콜은 4가지 단계가 있는데, 먼저 idle check - 데이터 작성 - 명령어 작성 - finish check이다. 이 네 스텝을 어떻게 수행하냐에 따라 기법이 나뉜다. 기법에는 Programmed IO, Interrupt driven IO, DMA가 있고, OS는 이를 적절히 섞어서 효율적으로 사용한다.
  
PIO는 Polling의 일환으로 디바이스의 idle check를 CPU가 while문으로 계속 체크한다.
Interrupt driven IO는 idle check와 finish check를 인터럽트를 통해 체크한다.
DMA는 네 스텝 모두 DMA 컨트롤러가 담당한다. CPU가 아닌 컨트롤러가 외부 장치와의 통신을 담당한다는 점에서 Polling의 반대이다.
  
Interrupt가 Polling 방식보다 무조건 좋을 것 같지만, Interrupt 구현을 위해서는, 인터럽트를 처리할 수 있는 핸들러와 이 핸들러를 저장해놓는 테이블이 필요하다. 이를 관리하는데에 오버헤드가 발생하므로, 느린 디바이스에는 인터럽트를, 빠른 디바이스에는 Polling을 사용하는 것이 좋다.
  
한편, DMA는 Direct Memory Access으로, 디바이스와 메모리 사이에 데이터 복사를 CPU가 아닌 DMA가 수행해, 원래 CPU가 데이터를 복사해야 할 시간을 DMA가 벌어주므로 overlapping이 가능해져 CPU 자원을 효율적으로 사용할 수 있다는 장점이 있다.
  
**2️⃣IO 주소 공간의 두 가지 설계 방식**
각 디바이스에는 레지스터가 있는데 이를 접근하는 방식에는 2가지가 있다. 메모리 주소 공간과 분리된 독립적인 IO 주소 공간이 존재하도록 하는 Direct IO, 이는 어느 주소 공간을 참조할지 명령어를 통해 지목해야하므로, 명령어가 많은 CISC 구조에 적합하다. 다음으로, 메모리 주소 공간의 일부에 IO 주소공간을 같이 두는 Memory-mapped IO 방식이 있는데 이는 따로 명령어로 어디를 지목하는 것이 아니라, 어느 주소에 접근하냐에 따라 메모리 또는 IO에 접근하는 것이다. 그래서 이는 명령어가 적은 구조인 RISC 구조에 사용하거나, 모바일 기기(ARM)에서 사용한다.
  
3️⃣디바이스 드라이버
디바이스 드라이버는 디바이스를 추상화하는 커널 내의 소프트웨어이다. 디바이스에 있는 레지스터를 제어하는 Device-specific 부분은 인터럽트와 DMA를 구현하고, OS의 포괄적인 인터페이스를 지원하는 OS-specific 부분이 있다. 이렇게 두 부분으로 이루어져 있다. 디바이스 드라이버는 두 종류가 있는데 사용자가 시스템 콜을 통해 직접 접근할 수 있는 Character device driver와 파일 시스템을 통해 접근해야하는 block device driver가 있다.
  
  
---
## 흐름과 핵심🫵🏻
![[Source/Untitled 47.png|Untitled 47.png]]