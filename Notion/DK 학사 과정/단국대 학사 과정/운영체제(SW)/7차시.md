---
p.13 Incorporating IO
**busy waiting**
![[Source/Untitled 40.png|Untitled 40.png]]
CPU를 가지고 있는 상태에서 대기하는 상태
CPU를 낭비하고 있는 상태이다.
**Blocked**
![[Source/Untitled 1 28.png|Untitled 1 28.png]]
CPU가 아무일도 하지 않고 대기하고 있는 상태라면 다른 프로세스를 수행한다.
IO 처리중인 A를 wait로 넣고 B를 run 상태로 넣어야한다.
IO가 끝난 A는 ready상태로 바꾼다.
---
  
p.14 8.MLFQ
**MLFQ**
Multi-Level Feedback Queue
**구조**
FIFO는 Turna타임이 좋고, RR는 Res타임이 좋다. 둘의 장점만 가져온 MLFQ가 있다.
여러 큐로 구성돼있다.(이때 말하는 큐는 ready queue이다.)
각 큐마다 다른 우선순위를 준다.
ready 상태의 잡은 하나의 큐에 들어있다.
**5개의 규칙을 사용**
![[Source/Untitled 2 19.png|Untitled 2 19.png]]
1. Priority(A) > Priority(B)라면 A를 B보다 우선 실행하라.
2. 같은 우선순위를 가질 때는 RR 방식으로 실행한다.
3. 새로 들어온 작업은 가장 높은 우선순위에 위치시킨다.
4. 1. 잡이 주어진 타임퀀텀만큼 다 사용하면 우선순위를 낮춘다.
    2. 잡이 주어진 타임퀀텀 CPU를 반납하면, 우선순위를 유지한다.(예를 들어 IO를 사용하기위해 CPU를 반납하는 경우)
  
CPU를 많이 사용(Batch 작업)한다면 점점 낮은 우선순위의 큐로 내려간다.
인터렉티브한 작업들은 우선순위가 유지된다.(상대적으로 높은 우선순위가 된다.)
  
**예시**
**CPU를 많이 사용하는 작업**
점점 우선순위가 낮아진다.
**새로운 작업이 도착**
![[Source/Untitled 3 18.png|Untitled 3 18.png]]
롱-런하고 있는 작업이 있는데 새로운 작업이 들어온다
새로운 작업은 최고 우선순위에 위치하므로 새 작업을 먼저 수행한다.
새 작업이 빨리 끝나는 작업이었다면 그걸로 좋고, 늦게 끝나는 작업이라면 우선순위가 점점 내려갈테니 그것도 괜찮다.
**롱런 작업 하나, IO작업 하나**
IO작업, 즉 인터렉티브한 작업은 우선순위가 계속 유지되어 사용자의 편의를 보장한다.
---
p.18
만약 빨리 끝내고 싶은 롱런작업이있다면?
nice() 시스템콜을 이용해 사용자가 OS에 힌트를 줄 수 있다.
  
만약 새로운 잡이 계속 들어와 기존 배치 작업이 실행되지 못한다면?
이것이 Starvation 이슈
  
**Issues**
Starvation
인터렉티브 잡이 너무 많다면 롱런 잡이 CPU시간을 할당받지 못한다.
스케줄러를 속일 수 있다.
배치 작업인데 인터렉티브 작업인 것 처럼 속일 수 있다.
time slice를 다 사용하지 않고 계속 반납하면 우선순위가 낮아지지 않는다.
프로그램이 행동을 바꿀 수 있다.
처음엔 배치 잡이었는데 인터렉티브 잡으로 바꿀 수 있다.
  
**Starvation을 피하기 위한 방법: Periodic boosting**
주기적으로 우선순위를 높여준다.
  
**스케줄러를 속이는 것을 피하기 위한 방법**
rule 4a, 4b를 바꾼다.
타임 슬라이스를 보지 않고 큐에서 할당받은 누적 시간을 본다.
  
---
p.25 MLFQ의 다른 이슈
**Issues**
큐를 몇 개로 할까?
타임 슬라이스를 큐 별로 다르게 줄까? 같게 줄까?
우선순위가 낮을 수록 긴 타임 슬라이스를 준다.
priority boost를 얼마나 자주 줄까?
  
Solaris의 스케줄링 큐
![[Source/Untitled 4 13.png|Untitled 4 13.png]]
---
p.23 Scheduling 비교