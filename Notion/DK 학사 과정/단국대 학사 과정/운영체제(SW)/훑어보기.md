## UFS
- 구조
    - 부트 섹터
    - 수퍼 블록
    - 비트맵 + 아이노드 + 유저 데이터
        - 비트맵은 파일 시스템의 블록 사용 상태를 추적
        - 아이노드는 파일의 메타데이터를 저장
        - 유저 데이터에는 실제 사용자 데이터 저장
- 접근 방법
    - 아이노드 접근과 데이터 접근을 번갈아가며 수행
    - 주의: 디스크의 기하학적 구조를 고려해야하고, 쓰기 작업당 여러 IO가 발생할 수 있다.
- 문제점
    - 긴 탐색시간(성능문제)
    - 일관성 문제
  
- 성능 문제
    - 아이노드와 유저 데이터가 다른 트랙에 위치함
        - 아이노드는 트랙의 가장 바깥쪽에, 데이터는 안쪽에 위
    - 시간이 지남에 따라 파일이 외부 단편화되어 긴 탐색 시간 필요
## FFS
Fast File System - 디스크 인식을 통해 성능을 향상시킨다.
동일한 실린더에 같은 네임스페이스를 갖는 데이터를 위치시켜 탐색 시간을 줄인다.
  
- 새로운 제안
    - 아이노드와 사용자 데이터 블록을 가능한 한 가깝게 배치
    - 디스크 인식(Disk awareness): 동일한 실린더에 데이터가 위치하면 탐색 거리 불필요, 하다못해 가까운 실린더에라도 데이터가 위치하면 탐색 시간이 줄어든다.
        - Ext2 ~ 4에서 이 아이디어를 사용한다.
  
- FFS의 용어 및 특징
    1. 파티션
        1. 하나의 물리적 저장 장치를 논리적으로 나눈 독립된 영역.
        2. 각 파티션은 별도의 파일 시스템을 가질 수 있고, OS에서 개별 드라이브로 인식된다.
            
            → 각 파티션에 OS를 설치하거나 데이터 분리 관리가 가능
            
    2. 실린더 그룹
        1. N개의 연속적인 실린더로 구성된다.
        2. 각 실린더 그룹의 구조
            1. 슈퍼블록(신뢰성을 위해 각 그룹들에 중복 저장된다.)
            2. 그룹별 비트맵, 아이노드, 데이터 블록
        3. 관리
            1. 같은 그룹에 아이노드와 데이터 할당
                1. 예를 들어, 파일 A의 아이노드와 데이터 → 그룹0, 파일 B의 아이노드와 데이터 → 그룹1, 이로써 탐색 거리를 줄인다.
1. FFS 특징
    
    1. 내부 구현은 실린더 그룹을 사용하여 다르지만, 외부 인터페이스는 기존의 파일 시스템과 동일하다.
    
      
    
- 중간 내용 보충
    - ‘그룹’이라는 말은 실린더 그룹을 의미한다.
    - 실린더 그룹에는 정해진 수의 아이노드가 있고, 이는 파일 시스템을 생성할 때 결정된다. 각 실린더 그룹에는 일정 수의 아이노드와 데이터 블록을 포함하고있다.
        - 현재 사용되지 않고 할당 가능한 아이노드를 ‘자유 아이노드’라고 부른다.
        - 디렉토리와 파일을 실린더 그룹에 할당할 떄, 자유 아이노드가 많은 실린더 그룹을 선택하여 균형있게 분산시킨다.
  
- FFS에서 파일과 디렉토리를 할당하는 정책
    - 기본 아이디어는 “관련된 데이터를 함께 배치”이다.
    - 할당 규칙
        1. 디렉토리
            1. 디렉토리를 자유 아이노드가 많은 실린더 그룹에 배치한다. 즉 현재 할당된 디렉토리가 적은 실린더 그룹에 배치한다.
            2. 이를 통해 디렉토리를 실린더 그룹 간에 균형있게 분산시킨다.
        2. 파일
            1. 파일을 해당 디렉토리가 속한 실린더 그룹에 배치한다.
            2. 파일의 데이터 블록을 해당 파일의 아이노드와 같은 그룹에 할당
            3. 이를 통해 아이노드, 데이터 블록, 디렉토리를 가능한 한 가까운 위치에 할당하여 성능을 최적화한다.
    - 할당 예시
        
        ![[Source/image 17.png|image 17.png]]
        
        - 위 그림과 같은 세 개의 디렉토리와 네 개의 파일을 생성하는 경우를 가정한다. 또한 디렉토리는 한 개의 블록, 파일은 두 개의 블록을 차지한다.
        - 규칙 1로 로드 밸런싱을 챙긴다.
            - 세 개의 디렉토리를 서로 다른 그룹에 할당한다.
        - 규칙 2로 네임스페이스 지역성을 챙긴다
            - 같은 디렉토리에 있는 파일들은 같은 그룹에 할당한다.
        - 예시 결과
            - FFS 할당은 네임스페이스 지역성을 강화하여, 관련된 데이터가 물리적으로 가까운 위치제 배치되도록 하여 탐색 시간을 줄인다.
  
- 중간 내용 보충
    - 파일의 데이터 블록에는 파일의 내용이 저장되고, 디렉토리의 데이터 블록에는 파일의 이름, 하위 디렉토리의 이름, 각 파일과 하위 디렉토리에 대한 아이노드 번호가 저장된다.
  
- FFS에서 큰 파일을 할당하는 방법
    - 큰 파일을 할당할 때 문제점
        - 큰 파일은 그 자체로 실린더 그룹을 채워버릴 수 있으며, 이는 네임스페이스 지역성을 고려할 때 바람직하지 않다.
    - 할당 규칙
        1. 큰 파일
            1. 한 그룹에 제한된 수의 블록(청크)을 할당한다. 그런 다음 다른 그룹으로 이동하여 거기서도 제한된 수의 블록(청크)를 할당한다. 이를 반복한다.
            2. 장점은 파일 ‘간’의 지역성 향상이고, 단점은 파일 ‘내’의 지역성 저하이다.
  
- 큰 파일을 접근할 때 발생하는 탐색 오버헤드
    - 규칙3 분석
        - 큰 파일에 접근할 때에는 규칙 3에 따라 탐색과 전송이 번갈아 가며 발생한다.
    - 예시
        
        - 가정
            
            |   |   |
            |---|---|
            |탐색 시간|10ms|
            |대역폭|40MB/s|
            
        - 상황 1
            
            - 그룹 내 제한된 청크 = 4MB
            
            |   |   |
            |---|---|
            |전송시간|4MB / (40MB/s) = 100ms|
            |탐색시간|10ms|
            |한 번 전송하고 탐색할 때의 총시간|110ms|
            |대역폭 사용 비율|90% (100ms / 110ms)|
            
        - 상황 2
            
            - 그룹 내 제한된 청크 = 400KB
            
            |   |   |
            |---|---|
            |전송시간|400KB / (40MB/s) = 10ms|
            |탐색시간|10ms|
            |한 번 전송하고 탐색할 때의 총시간|20ms|
            |대역폭 사용 비율|50% (10ms / 20ms)|
            
        
        한 번 전송하고 탐색하는 것을 반복하므로 위의 계산이 유의미하다.
        
        - 결론
            - 큰 청크는 탐색 오버헤드를 분산시켜 효율성을 높일 수 있다.
            - Amortization(할부 상환): 탐색 오버헤드를 분산시켜 데이터 전송 효율을 높이는 방법이다.(청크 사이즈를 늘려 탐색 오버헤드를 할부함)
  
- FFS의 추가 기능과 그 이점 및 단점
    
    - 요약
        
        **더 큰 디스크 블록 크기**:
        
        - 장점: 탐색 시간 감소, 데이터 전송 증가, 대역폭 사용 증가
        - 단점: 내부 단편화로 인한 공간 낭비
        
        **서브 블록 할당**: 내부 단편화를 극복하기 위해 사용
        
        **매개변수화**: 순차적인 블록 요청에서 발생하는 문제를 해결하기 위해 매개변수화된 배치 사용
        
        **기타 기능**: 심볼릭 링크, 원자적 이름 변경, 긴 파일 이름 지원
        
    
      
    
    1. 실린더 그룹(이전에 설명)
    2. 더 큰 디스크 블록 크기
        1. UFS에서는 512B → FFS에서는 4KB
        2. 장점은 더 큰 블록 크기로 탐색 시간이 줄고 더 많은 데이터를 전송하여 디스크에서 더 높은 대역폭을 사용한다는 것이다.
        3. 단점은 내부 단편화이다. (파일이 2KB라면 절반의 공간이 낭비됨)
    3. 서브 블록(fragment) 할당
        1. 내부 단편화를 극복하기 위해 사용된다.
        2. 4KB 블록을 4개의 1KB짜리 서브 블록으로 나눠서 할당한다.
    4. 매겨변수화(parameterization)
        1. 순차적 블록 요청에서 어떤 요청(예를 들어 2번 요청)이 디스크에 도착했을 때 디스크 헤드가 이미 위치 2를 지나쳤을 수 있다.
        2. 이를 매개변수화된 배치(parameterized placement)로 해결한다.
        3. 현대 디스크는 트랙 버퍼를 사용함.
    5. 여러 파일 시스템 간의 링크, 원자적 파일 이름 변경, 긴 파일 이름 지원 등이 있다.
## File system checker
- 비휘발성 - 공짜는 없다.
    - 디스크의 비휘발성 성질은 전원이 꺼져도 데이터를 유지할 수 있다는 장점이 있지만, 그 유지된 데이터들의 일관성을 유지해야한다는 이슈가 존재한다.
- 일관성이란
    - 파일 시스템에 변경 사항이 ‘유효한 상태’에서 적용되어야하고, 적용 후에도 마찬가지로 ‘유효한 상태’이어야한다.
    - 예를 들어 비트맵이 블록이 비어있다고 표시하지만 실은 사용중인 블록이라면, 이는 일관성이 없는 상태인 것이다.
  
- 해결책
    - FSCK
        - 파일 시스템 체크라는 뜻으로, 파일 시스템의 일관성을 검사하고 복구하는 도구이다.
    - 저널링
        - 변경 사항을 저널에 기록하여 크래시 후 빠르게 복구할 수 있다.
    - COW, Integrity checking, Optimistic 등 다양한 방법이 있다.
  
- 파일 수정 예시
    - 이 예시는 Simple FS으로 8개의 아이노드, 8개의 디스크 블록, i비트맵, d비트맵이 있다.
    - 파일의 크기는 4KB, 소유자는 Remzi이다.
    - 초기 상태는 inode 2가 사용 중이고, 데이터 블록 4가 사용중이다.
        - inode 2에는 파일 소유자, 권한, 크기 데이터 블록 포인터 정보가 저장된다.
    - 파일을 수정: 파일에 데이터를 추가하여 크기를 8KB로 증가
        1. 수정 후 inode 2가 여전히 사용중이며, 데이터 블록 4와 5가 사용중이다
        2. inode 2의 크기 정보와 데이터 블록 포인터가 업데이트 된다.
        3. 이 과정에서 세 곳을 변경해야 하므로 세 번의 쓰기가 필요하다.
  
- Crash scenario (크래시 시나리오)
    - **세 번의 쓰기**: Db, I[v2](업데이트된 아이노드), B[v2]
    - **지연 쓰기 (캐시 또는 큐 사용)**:
        - 예기치 않은 전원 손실 또는 시스템 크래시가 발생할 경우, 일부 쓰기만 완료되고 다른 쓰기는 완료되지 않을 수 있습니다.
        - 다양한 시나리오:
            - **Db만 디스크에 쓰여진 경우**: 문제 없음, 왜냐하면 비트맵과 아이노드에는 현재 Db가 있는 데이터 블록은 사용중이지 않으므로, Db가 없는 셈 치고 그 위에 덮어쓰면 됨.
            - **B[v2]만 디스크에 쓰여진 경우**: 공간 누수 발생. 데이터 블록이 사용중이라고 인식되므로 실제로는 비어있는 데이터 블록을 사용하지 못함.
            - **I[v2]만 디스크에 쓰여진 경우**:
                - 1) 잘못된 데이터 읽기
                    - 파일을 읽으려고 할 때, 아이노드는 새로운 데이터 블록(Db)를 가리키지만, 해당 블록에는 유효한 데이터가 없거나 이전 데이터가 남아있을 수 있다. 따라서 잘못된 데이터를 읽게 된다.
                - 2) 비일관성 (inode vs. 비트맵)
                    - 아이노드를 보면 5번 데이터 블록에 Db가 존재하고, 비트맵을 보면 존재하지 않는다. 이것이 일관된 정보를 제공하지 못하는 상황, 즉 비일관성이다. 이는 파일시스템의 무결성을 손상하고, 데이터 손실이나 오류를 초래할 수 있다.
            - **Db와 B[v2]가 디스크에 쓰여지고 I[v2]는 쓰여지지 않은 경우**: 비일관성 발생
            - **Db와 I[v2]가 디스크에 쓰여지고 B[v2]는 쓰여지지 않은 경우**: 비일관성 발생
            - **I[v2]와 B[v2]가 디스크에 쓰여지고 Db는 쓰여지지 않은 경우**: 잘못된 데이터 읽기
    - **일관성 필요성**:
        - 모든 수정 사항을 한 번에 쓰거나, 아무것도 쓰지 않아야 합니다 (일종의 원자성).
  
- 해결책 1: fsck
    - 여러 패스로 구성된다.
        - 슈퍼 블록은 파일 시스템의 메타데이터로, 보통 무결성 검사를 수행한다.
        - 자유 블록은 모든 아이노드와 사용된 블록을 검사한다. 비트맵에서 불일치가 발견되면 이를 수정한다.(보통 아이노드의 정보를 따른다.)
        - 각 아이노드의 유효성을 검사한다. 잘못된 아이노드는 복구한다.
            - 전체 디렉토리 트리를 스캔하여 링크 수를 확인한다. 아이노드는 있지만 디렉토리 항목이 없는 파일이라면, ‘lost+found’ 디렉토리로 이동한다.
            - 두개 이상의 아이노드가 가리키는 블록을 찾는다.
            - 유효 범위를 벗어난 포인터를 찾는다.
        - 디렉토리를 검사한다.(예를 들어 ‘.’과 ‘..’이 첫 번째 항목인지 확인한다.)
    - 문제점: 너무 느림
        - 그래서 저널링같은 현대적인 파일 시스템 복구 기법이 사용된다.
  
## Journaling
- Write-Ahead-Logging의 한 종류이다.
- 핵심 아이디어
    - 디스크를 업데이트 할 때, 구조를 덮어쓰기에 앞서 먼저 잘 알려진 위치에 무엇을 할 것인지에 대한 메모를 작성한다.
    - 장애가 발생한 경우 메모를 통해 의도한 작업을 파악하여 다시 진행하거나 취소할 수 있다. (redo or undo)
- 저널링을 가지는 파일시스템
    - 저널링을 지원하는 파일 시스템에는 Linux Ext3/4, IBM JFS, SGI XFS, NTFS, Reiserfs 등이 있다.
    - Ext3 파일 시스템의 특징
        1. 저널
            1. 모든 데이터 변경 사항을 저널에 기록한다.
        2. 순차적
            1. 먼저 메타데이터를 저널에 기록한 후 데이터 블록을 저장한다. 이는 기본 설정이다.
        3. 쓰기 불가
            1. 메타데이터를 저널에 기록하지만, 데이터 블록은 저널에 기록하지 않는다. 데이터 블록은 비순차적 방식으로 기록된다.
  
- 데이터 저널링
    - 스텝 1: 저널링
        - 최종 위치에 쓰기 전에 먼저 로그에 기록한다.
        - TxB는 트렌젝션 비긴으로 트랜잭션 ID와 쓰기 정보를 포함한다.
        - 로그를 작성하는데 두 가지 방법이 있다.
            - 물리적 로깅은 최종 작성할 내용과 같은 내용을 로그에 쓰는 것이다.
            - 논리적 로깅은 의도만 기록하는 것이다. 공간 절약은 되지만 더 복잡하다.
        - TxE는 트랜잭션 엔드로 트랜잭션 ID와 함께 종료한다.
    - 스텝 2: 체크포인팅
        - 위 트랜잭션이 디스크에 안전하게 저장된 후, 원래 데이터를 업데이트할 준비가 된다.
    - 복구하기
        - 저널링과 체크포인트 사이(TxE와 체크포인트 사이)에 장애 발생 시 저널을 재생해서 (redo) 다음 일관성 상태로 진입할 수 있다.
        - TxB와 TxE 사이에 장애 발생 시 저널을 제거해서 (undo) 이전의 일관성 상태로 유지할 수 있다.
  
- 저널링의 오버헤드를 줄이는 방법
    - 접근 방식 1: 모든 쓰기 한번에 수행
        - 모든 쓰기를 한 번에 수행하여 로그(저널)를 트랜잭션(모든 작업이 완전히 실행되거나 전혀 실행되지 않는 것을 보장하는 작업 단위)으로 기록하므로 유효해 보일 수 있다.
        - 하지만, 일부 쓰기 요청이 손실될 위험이 있어 안전하지 않은 접근 방식이다.
    - 접근 방식 2
        - 각 요청을 한 번에 처리하고 완료를 기다린 후 다음 요청을 발행한다.
        - 예를 들어 각 쓰기에서 fsync()를 호출한다.
        - 너무 느리다
    - 접근 방식 3: 커밋 사용
        - 다른 모든 쓰기와 TxE를 분리한다. 예를 들어 TxE 전에 fsync()를 호출한다.
        - 만약 커밋되지 않으면 undo 한다
        - 또는 커밋되었는데 원래 위치에 없다면 저널을 재생한다.
    - 접근 방식 4
        - 모든 쓰기를 한 번에 수행하고 저널의 모든 내용을 사용하여 체크섬을 적용한다.
        - 체크섬은 데이터의 모든 비트를 일정 방식으로 조합하여 만든 고유한 숫자 또는 문자이다.
        - 체크섬을 저장해두었다가 나중에 데이터를 읽을 때 체크섬을 재계산해 저장된 체크섬과 비교하여 데이터의 무결성을 보장할 수 있다.
## Ext2~4, FAT(file allocation table)
## 페이지 1 요약:
이 페이지는 Ext2, Ext3 파일 시스템의 특징을 다루고 있으며, Ext2와 Ext3의 주요 기능과 성능 개선 사항에 대해 설명합니다. 또한 Ext3에서 사용되는 저널링 방식을 설명하고 있으며, 관련 다이어그램을 포함하고 있습니다.
## 페이지 1 내용 번역 및 설명:
### Ext2
- **참고자료**: R. Card, T. Ts’o 및 S. Tweedie, "Design and Implementation of the second extended FS", [링크](http://e2fsprogs.sourceforge.net/ext2intro.html)
- **성능 개선**:
    1. 실린더 그룹 사용
    2. 사전 할당: 보통 8개의 인접한 블록
    3. 순차적 읽기 동안의 선행 읽기
### Ext3
- **Ext2 + 저널링**:
    - 저널링을 위해 블록 그룹이나 그룹 사용
    - 세 가지 종류: 1) 데이터 저널, 2) 순서 저널, 3) 쓰기 후 복구
- **다이어그램 설명**:
    - Ext2의 파티션 레이아웃 및 블록 그룹 레이아웃
    - 데이터와 저널링 블록 그룹 분포
## 페이지 1 내용 요약:
이 페이지는 Ext2 및 Ext3 파일 시스템의 주요 기능을 설명하며, Ext2가 성능 개선을 위한 다양한 기법을 사용하는 반면, Ext3는 저널링 기능을 추가하여 데이터를 더 안전하게 관리하는 방법을 기술합니다.
---
## 페이지 2 요약:
이 페이지는 Ext4 파일 시스템의 특징을 다루고 있습니다. Ext4의 성능 개선 사항과 디렉토리 항목 관리 방법을 설명하며, 관련 다이어그램을 포함하고 있습니다.
## 페이지 2 내용 번역 및 설명:
### Ext4
- **Ext3 + 더 큰 파일 시스템 용량 (64비트)**:
    - 대용량 파일 크기(예: 16TB) 및 파일 시스템(예: \(2^{64}\) 블록)을 지원
    - 디렉토리는 최대 64,000개의 하위 디렉토리를 포함할 수 있음
- **Extent-based 매핑**:
    - Extent: 가변 크기 (비교: Inode는 고정 크기 4KB)
    - 예: 연속된 16KB → 1개의 매핑 필요 (4개의 매핑 필요함)
    - Ext4, BtrFS, ZFS, NTFS, XFS 등에서 사용
    - 트리 구조(Extent 트리)에서 분할/병합 필요
- **해시 기반 디렉토리 항목 관리**
- **다이어그램 설명**:
    - 블록 기반과 Extent 기반의 메타데이터 레이아웃 비교
    - Ext4 Inode의 데이터 구조 설명
## 페이지 2 내용 요약:
이 페이지는 Ext4 파일 시스템의 특징을 설명하며, Ext4가 Ext3에 비해 더 큰 파일 및 파일 시스템을 지원하고 보다 효율적인 Extent 기반 매핑을 사용함을 강조합니다. 또한 해시 기반 디렉토리 항목 관리 방식을 통해 성능을 향상시키고 있습니다.
  
## 페이지 3 요약:
이 페이지는 FAT 파일 시스템의 특징과 그 아이디어를 설명합니다. FAT 파일 시스템이 사용하는 주요 개념과 메타데이터 관리 방식에 대해 설명하고 있으며, 관련 다이어그램도 포함되어 있습니다.
## 페이지 3 내용 번역 및 설명:
### 왜 FAT 파일 시스템인가?
- **대형과 소형 저장 장치**: USB, 메모리 카드, IoT 장치 등
- **메타데이터 공간 비용이 비쌈**
### 해결책: FAT 파일 시스템
- **개발자**: Microsoft
- **아이디어**: 비트맵, inode → FAT (파일 할당 테이블)
    - 사용/미사용 상태를 위해, 2) 데이터 위치(다음 블록 링크)
    - inode: 파일당 메타데이터 vs. FAT: 파일 시스템 당 모든 파일
    - 디렉토리 항목: FAT의 첫 번째 인덱스 가리킴
    - 메타데이터 (크기, 시간, 권한 등): 디렉토리 항목에 포함
- **다이어그램 설명**:
    - 한 디렉토리 항목의 구성 요소: 파일 이름, 파일 시작 클러스터, 파일 크기
    - 파일 할당 테이블의 구성
    - 디렉토리 항목이 FAT의 인덱스로 연결되는 방식
## 페이지 3 내용 요약:
이 페이지는 FAT 파일 시스템의 개념과 동작 방식을 설명합니다. FAT는 각 파일을 위한 inode 대신 하나의 파일 할당 테이블을 사용하여, 메타데이터의 공간 비용을 줄이는 방법을 보여줍니다.
---
## 페이지 4 요약:
이 페이지는 FAT 파일 시스템의 레이아웃 가정과 초기화 후의 작업 시나리오를 설명합니다. 또한 관련 다이어그램을 포함하고 있습니다.
## 페이지 4 내용 번역 및 설명:
### 예시
- **레이아웃 가정**:
    - 부트 섹터에 1블록, FAT에 2블록, 루트 디렉토리에 1블록 할당
- **작업 시나리오**:
    - 초기화 후
- **다이어그램 설명**:
    - FAT와 루트 디렉토리 초기화 후의 상태
    - FAT 블록과 루트 디렉토리 블록 배치
## 페이지 4 내용 요약:
이 페이지는 FAT 파일 시스템의 초기화 후 작업 시나리오를 설명합니다. 특정 레이아웃 가정을 기반으로 다양한 블록들의 위치와 초기 상태를 보여줍니다.
---
## 페이지 5 요약:
이 페이지는 FAT 파일 시스템에서 새로운 파일 생성과 컴파일 과정의 작업 시나리오를 설명합니다. 관련되는 다이어그램도 포함되어 있습니다.
## 페이지 5 내용 번역 및 설명:
### 예시
- **레이아웃 가정**:
    - 부트 섹터에 1블록, FAT에 2블록, 루트 디렉토리에 1블록 할당
- **작업 시나리오** (유사한 예: 40.3 에서 Inode):
    - 루트 디렉토리에 hello.c라는 새로운 파일 생성 (크기: 7KB)
    - 컴파일 후 a.out 파일 생성 (크기: 15KB)
- **다이어그램 설명**:
    - hello.c 파일 생성 후 FAT와 루트 디렉토리 업데이트
    - a.out 파일 컴파일 후 FAT와 루트 디렉토리 업데이트
    - hello.c와 a.out 파일의 내용 및 위치 표시
## 페이지 5 내용 요약:
이 페이지는 FAT 파일 시스템에서 파일 생성과 컴파일의 과정에 대해 설명합니다. 특정 레이아웃 가정을 기반으로 파일이 어떻게 할당되고, 데이터가 어떻게 관리되는지를 다이어그램과 함께 설명합니다.
  
## flash-aware FS
## 페이지 6 요약:
이 페이지는 디스크와 플래시 메모리의 차이점을 설명하고, 플래시 메모리에 최적화된 파일 시스템(Flash-aware FS)의 필요성을 강조합니다. 플래시 메모리의 읽기, 쓰기, 삭제 작업 및 페이지와 블록 개념에 대한 이해를 돕기 위해 다이어그램을 포함하고 있습니다.
## 페이지 6 내용 번역 및 설명:
### 왜?
- **디스크와 플래시 메모리 비교**:
    - 공통점: 비휘발성
    - 차이점:
        1. 플래시는 지우기 작업 필요
        2. 내구성 차이
        3. 읽기/쓰기: 작은 단위(4/8KB, 보통 페이지로 불림), 지우기 단위: 큰 단위(512KB, 보통 블록으로 불림)
        4. 기계적, 성능, 가격, 내충격성 등
- **다이어그램 설명**:
    - 디스크와 플래시 메모리의 읽기/쓰기 및 읽기/쓰기/삭제 과정 비교
    - 플래시 메모리 칩 구조 및 페이지와 블록의 관계 설명
## 페이지 6 내용 요약:
이 페이지는 디스크와 플래시 메모리의 차이점을 설명하고, 플래시 메모리의 특성을 반영한 파일 시스템의 필요성을 강조합니다. 읽기/쓰기와 삭제 작업이 플래시 메모리에서 어떻게 수행되는지를 다이어그램과 함께 설명합니다.
---
## 페이지 7 요약:
이 페이지는 플래시 메모리를 위한 파일 시스템(Flash-aware FS)의 해결책으로서 'Out-of-place update' 방식을 설명합니다. 이 방식의 원리와 이를 사용하는 실제 파일 시스템에 대해 다루고 있습니다.
## 페이지 7 내용 번역 및 설명:
### 해결책: Out-of-place update (기존 위치 업데이트가 아님)
- **새로운 디스크 블록 할당 (지움 상태) 및 쓰기**: 매핑 (주소 변환)을 통해
- **무효화된 디스크 블록 회수**: 가비지 컬렉션을 통해
- **예시**:
    - 파일 크기가 15KB이고 4개의 데이터 블록으로 구성된 경우
    - 이 파일을 수정하면 (0에서 10KB 범위)
    - 기존 위치 업데이트: 이미 할당된 블록에 쓰기
    - Out-of-place 업데이트: 새 블록을 할당하고 거기에 쓰기
- **실제 파일 시스템**: F2FS, LFS
- **다이어그램 설명**:
    - In-place 업데이트와 Out-of-place 업데이트의 다이어그램 비교
    - i-node 및 데이터 블록의 업데이트 과정
## 페이지 7 내용 요약:
이 페이지는 플래시 메모리 파일 시스템에서 Out-of-place 업데이트 방식을 설명합니다. 새로운 블록을 할당하여 업데이트하고, 기존 무효화된 블록을 회수하는 방법을 통해 효율성과 데이터 무결성을 유지하는 과정을 설명합니다.
---
## 페이지 8 요약:
이 페이지는 삼성에서 개발한 F2FS 파일 시스템의 주요 아이디어와 기능을 설명합니다. 또한 플래시 메모리를 위한 비플래시 인식 파일 시스템을 사용할 수 있는지도 다룹니다.
## 페이지 8 내용 번역 및 설명:
### F2FS: 삼성의 플래시 친화적 파일 시스템
- **핵심 아이디어**:
    - inode 사용 (FFS와 유사) 및 Out-of-place 업데이트 (LFS와 유사)
    - inode에 새로운 매핑 생성 및 예전 데이터 무효화 (번역)
    - 무효화된 블록 회수 (가비지 컬렉션)
- **새로운 기능**:
    1. 다중 로깅: 핫/콜드 분리
    2. NAT: 나무 탐색 문제 해결
    3. GC 최적화: 전경 vs 배경, 탐욕적 vs 비용
- **참고 사항**: 비플래시 인식 파일 시스템 (예: Ext4, FAT)을 사용할 수 있는가?
    - 예: FTL (플래시 변환 레이어) 사용으로
    - 플래시 메모리를 디스크처럼 추상화
    - 번역 (매핑), 2) GC, 3) Wear-leveling
- **다이어그램 설명**:
    - F2FS 구조와 주요 기능 설명
    - NAND 플래시 디바이스 구조 및 ECC (오류 수정 코드) 적용
## 페이지 8 내용 요약:
이 페이지는 삼성의 F2FS 파일 시스템의 주요 기능과 이점에 대해 설명합니다. 또한 플래시 메모리에 비플래시 인식 파일 시스템을 사용하는 방법과 관련된 FTL (플래시 변환 레이어)에 대해 다룹니다.