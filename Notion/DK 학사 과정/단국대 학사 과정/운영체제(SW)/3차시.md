---
p.20~23 동시성
**프로세스와 스레드**
차이점
스레드는 메모리를 공유하고(데이터를 공유)
프로세스는 메모리를 공유하지 않는다.
공통점은 CPU 입장에서 둘 다 독립적으로 본다는 점이다.
  
![[Source/Untitled 36.png|Untitled 36.png]]
10을 출력(데이터를 공유하지 않는다.)
![[Source/Untitled 1 24.png|Untitled 1 24.png]]
11 출력(데이터를 공유한다.)
![[Source/Untitled 2 15.png|Untitled 2 15.png]]
atoi()는 string to int 함수이다.
Pthread_create에서 스레드를 만들고 새로 만들어진 스레드는 worker를 수행한다.
Pthread_join()은 wait()와 같은 역할이다.
![[Source/Untitled 3 14.png|Untitled 3 14.png]]
-l pthread라고 써야함(pthread 라이브러리를 링킹해서 컴파일 하라는 옵션이다.)
-Wall은 모든 경고를 보이라는 옵션이다.
  
![[Source/Untitled 4 10.png|Untitled 4 10.png]]
원자성이 보장되지 않아서 이렇게 된다.
worker 함수에 lock, semaphore을 거는 등의 방법으로 원자성을 보장한다.
  
**동시성의 대표적인 문제 3가지**
producer-consumer
readers-writers
dining philosopher
  
**동시성은 프로그램이 서로 자원을 두고 경쟁하지 않고 서로 협력적이도록 설계할 수 있게 해준다.**
  
---
p.24 영속성
**Persistance**
유저는 데이터를 영원히 유지하기를 원한다.
디램은 휘발적이므로 디스크에 데이터를 쓸 필요가 있다.
디스크에 작성하는 것은 느리지만 빠른 것 같은 환상을 줘야한다. 이것이 영속성의 역할이다.
  
**DRAM과 Disk의 차이**
**접근 단위**
Dram은 바이트 단위로 접근
Disk는 섹터 단위로(512byte 등) 접근
**용량과 속도**
**휘발성 여부**
  
메모리에 쓰는 것은 변수 선언만 하면 되지만 disk에 쓰는 것은 명시적인 다른 동작이 필요하다.
  
![[Source/Untitled 5 10.png|Untitled 5 10.png]]
file에 작성하는 것이므로 디스크에 쓰는 것 같은데, 코드에서 디스크에 대한 언급이 없다.
OS는 디스크를 file로 추상화를 했으니 file에 쓰면 되기 때문이다.
  
---
p.27 OS를 설계할 때의 목표
**OS를 설계할 때의 목표**
1. 추상화
    
    내가 어느 레벨에 있는지 파악하고, 그 레벨에서 필요한 것만 가져오고 필요없는 것들은 숨긴다.
    
2. 성능
    
    오버헤드를 최소화 한다.
    
3. 보호
4. 신뢰성
5. 기타
    
    OS가 적용되는 분야에 따라 필요한 기능이 있을 수 있다.
    
6. 정책과 기법
    
    정책은 What(무엇을 하고싶다.) 기법은 How이다.
    
      
    
---
p.29 OS의 역사
**초기 OS: 라이브러리**
예를들어 DOS는 디스크에 동작하기 위한 함수들을 모아놓은 라이브러리였다.
**라이브러리를 넘어서: 보호**
보호의 개념이 들어오면서 유저와 커널 모드를 구별하기 시작했다.
**멀티프로그래밍**
  
**멀티태스킹**
cpu가 여러 프로그램을 돌아가면서 수행하도록 한다.
가장 성공한 멀티태스킹 시스템이 UNIX이다.
Ken Thompson(Go 창시자)과 Dennis Ritche(C언어 창시자)가 만들었다.
  
---
p.33 요약
OS는 자원관리자
OS의 핵심 요소는 가상화, 병렬성, 영속성이다.
OS은 보안, 네트워크, 그래픽도 중요한 요소이다.