**OS**
**Virtualization(가상화)**
CPU 관련 가상화
메모리 관련 가상화
**Concurrency(병행성)**
병렬처리
2개 이상의 프로세스가 동시에 자원을 사용해야할 때 일반성이나 순서 관계를 어떻게 주는지에 대한 이야기이다.
**Persistence(영속성)**
데이터를 영속적으로(비휘발적으로) 보존하기 위한 이야기
  
컴퓨터는 층 구조이다.
가장 아래쪽에 HW
그 위에 OS가 존재한다. HW를 제어
그 위에 System Programs, App Programs
그 위에 Users가 있다.
  
**HW**
CPU
Main memory
주소와 내용의 쌍
내용은 명령어 또는 데이터이다.
변수 선언을 하면 데이터에 올라간다.
연산은 명령어이다.
I/O device
버퍼를 가지고 있다.
입출력을 할 때 데이터를 잠깐 담아두는 역할을 한다.
키보드에도 작은 메모리가 있는데 그것이 버퍼이다.
---
p.9~13
### 1. 프로그램 동작의 간단한 설명
**컴퓨터는 어떻게 동작하는가?**
Fetch와 Execute를 반복하며 동작한다.
  
  
### 2. 프로그램을 실행하기 위해 필요한 많은 것들
Fetch, Execute를 진행하기 전에 로딩, 메모리 관리, 스케줄링 등이 필요하다.
이것들을 관리하는 것이 OS의 역할이다.
OS는 프로그램을 편하게 수행할 수 있도록 이런 것들을 관리해주는 역할.
  
**OS의 역할**
1. 리소스 매니저
    
    물리적(CPU, DRAM 등 HW 자원), 논리적 자원(HW를 추상화한 자원, Process, Page, virtual Memory, File)을 관리한다.
    
2. 가상화(추상화)
    
    물리적 자원을 더욱 유연하고 사용하기 쉬운 형태로 변환하는 것이 추상화이다.
    
  
**System Call (OS가 제공하는 서비스)**
![[Source/Untitled 35.png|Untitled 35.png]]
**표준화가 잘 돼있다.**
Unix에서 제공하는 시스템콜을 POSIX 규정을 따른다고 한다.
윈도우의 시스템콜은 Win32(윈삼이)를 따른다고 한다.
Mode Switch
컴퓨터에는 2개의 모드가 있다. 유저 모드와 커널 모드
왜 모드가 나뉘어있나?
일반 프로그램은 유저 모드로 동작한다. 이들은 죽어도 큰 영향 x
OS가 죽으면 커널 모드로 동작한다. 이들은 죽으면 큰 영향이 있다.
  
시스템콜이 발생할 때마다 유저모드 → 커널 모드로 모드스위치 발생
시스템콜이 끝나면 커널모드 → 유저모드로 모드스위치 발생
---
p.14~16
## 2.1 CPU 가상화
![[Source/Untitled 1 23.png|Untitled 1 23.png]]
&: 백그라운드 실행
쉘이 자식 프로세스를 기다리지 않고 쉘대로 동작한다.
위의 코드는 4개의 프로세스를 만든 것이다.
스케줄링 순서가 다름에 주목하자.(다다음 강의노트에서 배운다.)
  
OS는 사용자에게 “내가 사용하고있는 시스템은 CPU가 무한대로 많다”는 환상을 주어야한다.
  
---
p.17~19
## 2.2 Memory 가상화
![[Source/Untitled 2 14.png|Untitled 2 14.png]]
![[Source/Untitled 3 13.png|Untitled 3 13.png]]
두 20만 번지는 각각의 다른 논리적 메모리위의 20만번지들이다.
  
  
### **복습**