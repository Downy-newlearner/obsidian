## Ch. 39
---
Ch39.7 Writing Immediately with fsyc(), p30
### Performance consideration for write
지연 쓰기
디스크에 바로바로 작성하지 않고 버퍼(또는 캐시)에 작성하고 5초에서 30초 간격으로 디스크에 쓴다.
Write grouping과 Write reordering이 성능을 향상시킨다.
DRAM은 Disk 입장에선 캐시이다, CPU cache는 DRAM입장에서 캐시이다.
동기적
디스크에 써달라는 명령에 바로바로 써준다
비동기적(default)
바로바로 써주지 않는다.
### concern of delayed write
- Durability
    - 영속성 측면에서 문제가 있다.
- How to guarantee durability
    
    - fsync()를 사용하면 더티한 데이터(아직 디스크에 작성하지 않고 캐시에서 대기중인 데이터)들을 바로바로 디스크에 써준다.
    
      
    
---
p.31
### Change a file name : mv 명령어
API viewpoint: editor example(편집기의 동작 과정)
foo.txt의 이름을 수정하려고 한다
먼저 foo.txt와 같은 내용을 가지는 foo.txt.tmp를 만든다.
수정을 마치면 foo.txt.tmp를 foo.txt라는 이름으로 이름을 바꿔준다.
### Remove a file : unlink 명령
API
unlink(file name)를 사용한다.
---
p.32
### Contents in a file system
- 파일 시스템에서 데이터의 두 종류는 사용자 데이터와 메타 데이터가 있다.
    
    사용자 데이터는 사용자가 작성한 데이터이다.
    
    메타데이터는 파일시스템이 파일 관리(아이노드) 및 파일 시스템 관리(슈퍼 블록) 목적으로 작성한 데이터이다.
    
      
    
- 특정 파일의 메타데이터를 확인하는 API
    
    - stat는 첫 인자가 파일 이름이다.
    - fstat는 첫 인자가 fd
    
    둘 중 선호하는 것을 사용하면 된다.
    
---
p. 33
### 디렉토리를 만드는 API
- mkdir(name, permission)
    - 디렉토리를 만들면 기본으로 ./과 ../이 만들어진다.
  
### 디렉토리를 삭제하는 API
- rmdir(file_name)
    - 매우 조심히 써야한다.
  
### 디렉토리를 읽기 위한 API
- opendir(dp)
- readdir(dp)
- closedir(dp)
- ls는 readdir()로 구현되어있다.
- ls -l은 readdir() + stat()이다.
---
### Hard Link
- 윈도우의 바로가기와 비슷하고, 같은 파일시스템 내애서만 링크를 걸 수 있다.
- 하드 링크는 기존 파일에 엑세스할 수 있는 다른 파일 이름을 만든다.
- 새로운 파일 이름을 만들고 기존 아이노드를 공유한다.
  
- link(old_name, new_name) 명령어로 사용할 수 있다.
- unlink()로 하드 링크를 해제할 수 있다. 만약 하드링크를 해제하지 않으면 하나를 삭제하더라도 여전히 나머지 하나로 접근할 수 있다.
- 링크 수가 0이 되면 데이터를 삭제하는 원리이다.
### Soft Link(Symbolic Links)
- 새로운 파일 이름을 만들 뿐만 아니라 새로운 아이노드도 설정한다.(심볼릭 링크로 설정)
- 리눅스는 여러 파일시스템을 마운트해서 사용하므로 다른 파일시스템으로의 링크를 걸기 위해서 사용한다.
    - 다른 파일 시스템 간에 링크할 수 있고, 디렉토리를 링크할 수 있다.
  
- Dangling reference
    - 심볼릭 링크에서 원본 파일이 삭제되거나 이동된 후에도 링크는 남아있을 수 있으며, 이를 덩글링 레퍼런스라고 한다.
  
|   |   |   |
|---|---|---|
||아이노드|링크 수(0이 되면 데이터 삭제)|
|하드 링크|동일한 아이노드 번호 공유|링크 수에 포함|
|심볼릭 링크|서로 다른 아이노드 번호를 가짐(원본 파일을 가리킴)|링크 수에 포함하지 않음(그래서 덩글링 레퍼런스 발생 가능)|
||||
  
### Permission bits
user, group, other의 권한을 표시하는 비트이다.
---
### Making and Mounting a File system
- 파일 시스템 만들기
    - 디렉터리와 파일을 조립한다.
    - 관련 메타데이터는 슈퍼 블록과 비트맵이 있다
    - 사용 명령어는 `mkfs`이다.
        - 디스크 파티션에 빈 파일 시스템(루트 디렉토리만 포함)을 만든다.
    - 파티션 만드는 명령어는 `fdisk`이다.
    - 예시
        - /dev/sda란?
            - 리눅스에서 사용하는 장치 파일 중 하나로, 컴퓨터의 첫 번째 SCSI 하드 드라이브를 나타낸다.
  
- 마운트
    - 파일 시스템을 사용자에게 보이게 한다.
    - 통일된 디렉터리 트리 내에 여러 파일시스템을 연결한다.
    - 마운트 명령어 인자
        
        1. 파일 시스템 종류
        2. 파티션
        3. 마운트 지점
        
        예시: **mount -t ext3 /dev/sda4 /mnt**
        
    - `/mnt`는 마운트된 파일 시스템의 루트를 가리킨다.
  
---
## Ch.40 File System Implementation
---
p. 40
### Objective of this chapter
파일 시스템 구현의 목표와 VSFS(매우 단순한 파일 시스템)의 개념을 설명한다.
  
- 디스크
    - 파티션으로 구성된다. 그리고 각 파티션에 파일 시스템이 생성된다.
  
- 파티션
    - 디스크 블록으로 구성된다.
    - 사용자 데이터는 디스크 블록에 저장된다.
  
### Layout of a file system(VSFS)
- 슈퍼 블록(0번 블록)
    
    - 파일 시스템을 관리하는 메타데이터이다. 파일 시스템당 하나의 슈퍼 블록이 있다.
    - 데이터 블록 수, 아이노드, 시작위치 등을 담고있다.
    - 마운트 기능 중에 사용된다.
    
      
    
- 비트맵(1~2번 블록)
    
    - 자유 공간을 관리하는 메타데이터이다.
    - 아이노드용 비트맵, 데이터 블록용 비트맵. 이렇게 총 2개 있다.
    
      
    
- 아이노드(3~7번 블록)
    
    - 파일을 관리하기 위한 메타데이터이다. 파일당 하나의 아이노드가 매치된다.
    - 아이노드의 크기는 256Byte로 블록이 4KB이므로 한 블록당 16개의 아이노드가 할당된다.
    
      
    
- 사용자 데이터(8~63번 블록, 동적으로 조절 가능)
    - 사용자가 작성한 데이터이다.
  
### 아이노드
- 파일을 위한 메타데이터를 관리하는 법
    
    1. 아이노드
        - 아이노드는 파일 정보(모드, uid, 크기, 시간, 링크 수, 블록 등)를 기록하고, stat() 명령어를 통해 접근 가능하다.
            - 파일 정보
                1. mode는 파일을 읽을 수 있는지, 쓸 수 있는지, 실행할 수 있는지에 대한 메타데이터이다.
                2. uid는 누가 파일을 소유하고 있는지에 대한 메타데이터이다.
        - 또한 사용자 데이터 블록의 위치를 다중 수준 인덱스 및 불균형 트리로 저장한다.
            - Direct block pointers
            - 단일 / 이중 / 삼중 간접 블록 포인터
            - 장점은 작은 파일은 빠르게 접근, 큰 파일은 대용량 지원한다는 점이다.
    2. FAT(연결 기반), Extent-based, Log-based 등
    
      
    
- 아이노드가 지원하는 최대 파일 사이즈
    - 합산 48KB + 4MB + 4GB + 4TB
    - 한 개의 블록에 4바이트 주소가 1024개 들어갈 수 있으므로 위와 같은 연산이 나온다.
  
- 아이노드 조작 예시
    - 12개의 직접 블록이 있다고 가정한다.
    - 크기가 7KB인 새 파일, hello.c이 있고, 이를 컴파일 하면 70KB의 a.out이 된다고 하자.
        
        |   |   |   |
        |---|---|---|
        |hello.c|블록 2개 필요||
        |a.out|블록 18개 필요(인덱스 블록까지 19개 필요)|직접 블록의 개수가 부족하므로 1개의 single indirect block까지 해서 19의 블록을 사용한다.|
        
    - 아이노드 구성
        
        1. 루트 디렉토리의 아이노드
            1. 데이터 블록의 위치는 8
        2. hello.c의 아이노드
            1. 데이터 블록의 위치는 9, 10
        3. a.out의 아이노드
            1. 데이터 블록의 위치는 11~23
            2. 23번은 인덱스 블록이다
        
          
        
- inode와 데이터의 위치를 찾는 방법
    - 디렉토리 엔트리: <file name, i_number>
    - i_number를 아이노드 테이블의 인덱스로 사용하여 위치를 찾는다.
    - 예시
        - i_number = 33인 경우 33 / (블록당 아이노드 수)를 한다.
            - 33 / 16 = 2 … 1
        - 아이노드 테이블의 시작 지점(12KB, 아이노드 테이블 앞에는 슈퍼 블록과 비트맵 두 개가 있다. 그래서 네 번째 디스크 블록부터 아이노드 테이블) 에서 ‘디스크 블록 크기 * 몫’을 더한다.
            - 12KB + 4KB * 2 = 20KB
        - 이후 ‘아이노드 사이즈 * 나머지’만큼 더한다.
            
            - 20KB + 256*1Byte
            
              
            
- 사용자 데이터의 위치를 찾는 방법
    
    1. 아이노드 찾기
    2. 파일의 현재 오프셋 / 디스크 블록 크기
        1. 몫은 포인터 위치를 찾는데 사용
        2. 나머지는 디스크 블록 내에서 오프셋으로 사용
    
    - 예시
        
        - 파일의 현재 오프셋 = 5000 이라고 가정
            - 5000 / 4096 = 1…904
        - 몫은 포인터의 위치이므로 아이노드에서 인덱스 1번의 포인터를 찾는다.(이전 예시에서 a.out의 경우 블록 12)
        - 블록 12를 읽어서 블록 내 904 위치로 이동한다.
        
          
        
[[40장 나머지 내용은 내일 정리하기]]
퀴즈와 어펜딕스도 다 해야한다.