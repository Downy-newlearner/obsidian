## 복습
mov 명령어를 배웠다
movw movl 등의 차이(오퍼랜드의 사이즈 차이이다.)
산술연산
분기 : jle jmp
  
## 반복문 p.26
중간에 점프 2번이 있다
c언어의 반복문
for
while
do while
  
## 함수
함수는 스택을 사용한다.
스택의 바닥과 스택의 탑이라고 한다
바닥 : SS(스택 세그먼트) 가 가리킨다.
탑 : esp(스택 포인터)가 가리킨다.
  
푸시
탑을 한 칸 내리고(0x108 → 0x104) 인자값(%eax)을 추가한다.
스택은 위에서 아래로 자란다.
  
pop
탑의 값을 %edx에 넣는다.(edx의 초깃값은 0)
탑을 한 칸 높인다.
  
## ==p.28 시험 출제==
참고 : [https://ejrtmtm2.wordpress.com/2013/04/10/프로그램-실행-과정에-따른-스택의-동작-이해하기-13년/](https://ejrtmtm2.wordpress.com/2013/04/10/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%8A%A4%ED%83%9D%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-13%EB%85%84/)
<시험 예시>
call 호출 전후 스택 상태를 적으시오
호출 전 : 인자만 스택에 push
호출 후 :
leave 명령어 실행 전후 스택 상태를 적으시오
  
함수 이름이 레이블로 되어있다.
레이블은 곧 주소이다.
함수 이름은 주소이다.
함수 호출을 한다는 건 새로운 스택프레임을 만든다는 뜻이다.
1. 인자를 역순으로 push
  
1. call func1
    
    call은 jump와 비슷하다.
    
    jump는 무조건 간다.
    
    call은 갔다가 돌아올 주소를 스택에 저장한다.
    
    call은 EIP를 스택에 넣는다. (EIP는 다음에 수행할 명령어를 가리킨다.)
    
    EIP는 call다음 명령어 즉, addl를 가리키고있다.
    
    그것을 스택에 넣는다.(함수가 끝나면 돌아올 주소, return address)
    
      
    
2. 인텔 명령어의 처음은 saved ebp이다.
    
    즉 함수가 시작되고나서 스택에 saved ebp를 push한다.
    
    이때 지금까지 푸시한 모든 것들은 integer 즉 4byte이다.(한 칸에 4바이트이다.)
    
    예제에서 esp에 8을 뺀다는 것은 2칸 내린다는 뜻이다.
    
    이것은 a, b를 넣을 수 있는 공간을 만든다.
    
    ebp 주소에 -4하면 첫 번째 지역 변수의 주소이다.
    
    ebp+8은 첫번쨰 인자의 주소이다.
    
    그래서 첫번쨰 인자에 4를 더하라는 명령은
    
    addl $4, +8(%ebp)
    
    CPU나 어셈블러는 변수 이름을 사용하지 않기 때문에 인자 또는 지역변수를 지목하기 위한 기준점이 필요한데 %ebp를 기준으로 사용한다.
    
    p.11 : EBP 설명 읽어보기
    
이렇게 스택 프레임이 만들어지고 이것이 func1을 위한 스택프레임이다.
  
1. 함수의 리턴값은 %eax에 넣는다.
  
  
1. 함수가 끝나고 addl $8, %esp를 하면서 함수에 넣어진 인자도 반납
    
    비로소 함수를 호출하기 전과 같은 스택 상태로 돌려놓는다.
    
      
    
## 어셈블리 프로그램 만들기 p.33
![[Source/Untitled 117.png|Untitled 117.png]]
2개의 파일을 사용
main.c, asm_sum.s
  
머리: 스택 푸시하는 부분(asm_sum:부터 3줄(pushl, movl, subl))
  
saved ebp  
move %esp, %ebp
subl $4, %esp
  
ebp 푸시 → 스택 포인터를 ebp로 → esp를 한 칸 아래로(4 바이트 빼기)
  
꼬리 : 스택을 정리하는 부분(L2:)
지역변수(ebp 한 칸 위)를 리턴값으로 넣어준다.
  
몸체 :
첫번쨰 인자를 %ecx에 넣는다. (5)
첫번째 인자에 0을 넣는다.
이하 직접 읽어보기
  
.으로 시작하는 어셈블리 명령어는 peusdo 명령어이다.
어셈블리가 시작할 때 지시하는 역할을 한다.
.text는 아래로 모두 text 메모리로 들어갈거라는 뜻이다.
.global은 뒤에 붙는 함수 이름을 어딘가에 등록해서 사용할 수 있게 한다.
그래서 인클루드 안해도 사용할 수 있다.
  
-4(%ebp) 같은 것을 displacement(base)라고 한다.
나중에 설명
  
## p.35
main()
머리는 ebp push하고 esp를 ebp로 맞춘다.
몸체
pushl $arg
주소 자체를 push한다.
그러기 위해서 $arg처럼 $를 사용한다.
arg를 push하면 arg 내용이 push되고
$arg를 push하면 arg 주소가 push된다.
  
==기말고사에 어셈블리코드를 주고 수행 결과를 쓰라고 나온다.==
  
## directive
.으로 시작한다.
지시자의 역할
지시자는 어셈블러에 정보를 주기 위해 사용된다.
지시자의 종류는 p.36 참고