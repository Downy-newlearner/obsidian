메모리 내용이 cpu 위로 올라가서의 상황
레지스터의 종류 등
어셈블리 언어로 배울 것이다.
  
언어계층
High
Assembly
CPU dependent
Machine
그나마 cpu에 가깝고 사람이 읽을 수 있는 어셈블리어로 공부한다.
  
적용 분야
하드웨어 제어
디바이스 드라이버, 임베디드, ecu 즉 자동차 안 부품 engine control unit 등에서 어셈블리어를 사용한다.
취약점 테스트
바이러스는 기계어로 들어오고 그것을 식별하려면 기계어를 분석해야한다 디스어샘블해서 어셈블리어로 분석한다.
최적화 분야
소프트웨어 카피라이트 보호
디버깅 할 때도 사용
  
어셈블리를 이해하면 cpu를 이해할 수 있다.
  
## CPU
다양한 관점으로 보는 CPU
- 트랜지스터, 게이트, 논리, 클락 들의 집합
    - 트랜지스터는 스위치다 눌리면 전류가 흐르고 눌리지 않으면 흐르지 않는다.
    - 이것을 묶으면 여러가지 게이트를 만들 수 있다.
        - 덧셈기를 만들 수 있다(뺄셈 기능도 가능)
        - 이렇게 ALU, MUX도 만들 수 있다.
    - 디지털 논리회로 수업 관점
- ALU, 레지스터, 컨트롤 유닛을 만들고 시스템 버스로 연결한 것
    - 컴구 관점
- ==명령어 집합 아키텍처(Instruction Set Architecture)==
    - CISC
    - RISC
    - VLIW
    - EPIC
    - 시프 과목에서는 이 관점에서 볼 것이다.
- 성능 관점
    
    - 파이프라인
    - 슈퍼스칼라
    
      
    
### Instruction Set Architecture
[[Instruction set architecture(ISA)]]
Register + Instructions
메모리 - cpu에서 연산 - 메모리로 돌아감
레지스터 모델
메모리 모델
명령어 모델
모두 인텔 기준으로 알아볼 것이다.
  
퍼포먼스 특성
파이프라인
- Add a,%eax라는 명령어를 수행하기 위해서는 다음과 같은 단계가 필요하다.
    
    명령어 인츨
    
    Cpu가 명령어 해독
    
    데이터 인출
    
    수행
    
    결과 저장
    
      
    
- 파이프라인이 유지되려면 모든 명령어들이 비슷한 구성을 가져야한다.
    
    CISC보다 RISC가 선호되는 이유이다.
    
      
    
- 그런데 파이프라인을 사용하면 동시에 처리할 수 없는 명령어의 부분들이 있다.
    - 버스 수를 늘리는 방법이 있지만 비쌌다.
    - L1캐시는 데이터캐시와 명령어 캐시로 나뉘어있다.
        
        - 데이터와 명령어를 동시에 가져올 수 있다.
        
          
        
- 명령어 인출이 이전 명령어 수행에 따라 영향을 받아야 할 때
    
    - ex
        
        If h==0 이면 a++
        
        else b++
        
    
      
    
    - 추론 수행(speculation execution)
        - 두개 다 실행해놓고 맞는 결과를 가져다 사용한다.
        - 비싸다
    - 분기 예측(branch prediction)
        - h가 어떤 값이 자주 나오는지 예측 가능한 경우가 매우 많다.
        - 예측해서 실행해놓는다.
        - for(i=0; I<1000; I++) 이런 경우는 분기 예측이 매우 쉽다
            - i<1000이 분기 조건
    
      
    
## 레지스터 모델
EIP가 PC이다.
레지스터는 CPU에서 사용가능한 작은 사이즈의 메모리이다.
레지스터는 매우 빠르게 접근할 수 있다.
  
AX, EAX, RAX의 차이
레지스터 크기의 차이가 있다.
순서대로 16bit - 32bit - 64bit이다.
  
- Segment register
    
    - 세그먼트란, 메모리를 조각내어 각 조각마다 시작주소, 범위, 접근 권한 등을 부여해서 메모리를 보호하는 기법이다.
    - CS, DS, SS, ES
    
      
    
- General purpose register
    
    - EAX, EBX, ECX, EDX
        - 순서대로 Accumulator, Base, Counter, Data
        - 주로 산술연산 명령어에서 상수/변수 값의 저장 용도로 많이 사용된다.
        - ECX는 반복문 명령어(루프)에서 반복 카운트로 사용되는데 루프를 돌 때마다 ECX를 1씩 감소시킨다.
        - EAX는 일반적으로 함수 리턴 값에 사용된다.
    - EBP
        - 함수가 호출되었을 때 그 순간의 ESP를 저장하고 있다가 함수가 리턴하기 직전에 다시 SEP에 값을 되돌려줘서 스택이 깨지지 않게 한다.
        - 즉, 스택 프레임의 기준점 역할을 한다.
    - ESP
        - 스택 포인터
    
      
    
- EIP
    - PC의 역할을 한다.
  
  
자세한 내용은 교수님 강의 사이트 인텔 메뉴얼에서 확인할 수 있다.
  
## 메모리 모델
로지컬 주소 (virtual model)
Linear address
Physical address
  
Logical에서 세그맨테이션으로 linear로 바뀌고 페이징으로 physical로 바뀐다.
로지컬 리뉴얼 피지컬 주소는 각각 컨셉의 메모리에 올라간다.
13페이지 참고
리니어 피지컬은 여러 프로세스의 메모리가 동시에 올라가있다.
각 프로세스의 메모리 위치를 매핑을 통해 알려주는데 그것이 세그맨테이션이다.
리뉴얼 메모리의 stack은 3개 페이지 text는 2개의 페이지, data는 1개의 페이지를 갖는다고 가정 한 그림
피지컬의 페이지는 모두 같은 크기를 갖는다.
  
새그멘테이션은 가변 크기
페이지는 고정 크기이다.
4KB이다.
로지컬 어드레스는 세그먼트 정보와 오프셋으로 구성된다.
이것으로 리뉴어 어드레스의 위치를 찾을 수 있다.
리뉴어 어드레스는 테이블과 오프셋이 있다.
그것으로 피지컬 어드레스의 위치를 찾을 수 있다.