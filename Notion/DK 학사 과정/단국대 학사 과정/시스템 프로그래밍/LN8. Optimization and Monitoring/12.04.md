## 프로그램의 퍼포먼스 표현하기
- CPE
    
    - Cycles Per Element
    - 성능을 표현한다.
    - CPE를 통해 서로 다른 SW의 성능을 비교할 수 있다.
    
      
    
  
p.7~
  
## combine1
- 초기화를 시킨다
- for 루프를 length 크기만큼 돌면서 엘리먼트를 가져온다.
- 그것을 초기화된 포인터에 OPER 한다.
    - OPER이 덧셈이면 엘리먼트들을 다 더한다.
    - OEPR이 곱셈이라면 엘리먼트의 곱을 구한다.
  
## 최적화
- combine1을 어떻게 최적화 할 수 있을까?
    - for루프 안에 없어도 되는 것을 밖으로 빼자(빈번하게 사용되는 부분을 최적화해야한다.)
        
        - for문의 조건부 i<vec_length(v)를 밖으로 뺀다. → combine2
            - Code motion이라고 한다.
        - data_t val을 밖으로 뺴는 건 성능의 차이가 거의 없다.
        
          
        
- 함수 호출은 오버헤드가 큰 동작이다.
    - 가능하면 함수 호출 횟수를 줄이는 것이 좋다. → combine3
        - Reducing procedure calls, Direct data access
  
- 블록 안에 블록 밖 변수를 사용하면 접근하는 데에 지역변수보다 시간이 많이 걸린다.
    - 블록 밖 변수보다 지역변수를 사용하면 그 지역변수는 블록 밖에서 알 필요 없는 데이터라 레지스터에 저장한다. → combine4
        
        - Accumulate in temporary
        
          
        
          
        
- combine4의 한 루프는 4CPE?
    - 덧셈은 add incl cmpl jl → 2CPE
    - 곱셈은 4CPE
    - 왜?
        - p.18
        - FP는 floating point
        - two main unit
            
            - instructino control
                - 오퍼레이션을 만들 때 명령어에 따라 다르다.
                    - 첫 명령어는 하나의 하나의 오퍼레이션
                    - 두 번째 명령어는 세 개의 오퍼레이션
            - execution unit
            
              
            
- P6 아키텍쳐 핵심 기술
    - 슈퍼 스칼라
        - 한 클락에 명령어 동시 수행
    - 무순서 수행
        - 필요에 따라 명령어 수행 순서 바꿈
    - 분기 예측
    - 추론 수행
        - A또는 B 명령어 둘 중 하나가 실행되고 당장 무엇이 실행될지 모른다면 둘다 실행해놓음
    - 레지스터 리네이밍
  
- 명령어의 퍼포먼스
    - add
        - shift, cml도 같다.
        - 1
    - mul
        - 4
    - 이슈타임
        - 앞에 곱셈이 들어가고 얼마나 이따가 파이프라인으로 수행될 수 있느냐
        - 나눗셈은 파이프라인이 안 되는 것이다.
  
- combine4의 동작 p.24
    - load를 보면 파이프라인이 되고있음을 알 수 있다.
    - dependency때문에 load → imull 수행
        - 또한 iteration1,2,3의 imull은 서로 파이프라인 될 수 없음(dependency 때문에)
    - 무순서 수행
        - i=0일때 i=1, i=2 등이 같이 돌고 있다
    - branch prediction
        - 다음 루프의 조건문이 만족하는지 모르지만 일단 실행한다.
- CPE는 사이클이 증가할 때마다 엘리먼트가 몇 개씩 증가하느냐이다.
    - 그래서 CPE는 4이다.
- 하지만 P6에서는 24페이지처럼 수행될 수 없다.
    - 인티저 유닛이 2개라 iteration0,1까지만 수행되고 iteration3은 0이 끝나고 수행되어야한다.
    - ==그래서 CPE가 3이다. ???==
- for루프를 돌리기 위해 로드 인클리먼트 컴페어 점프가 너무 많다.
    - loop unrolling
    - 한 루프안에 더하기 연산을 많이 넣어주면 로드 인클리먼트 컴페어 점프의 횟수를 줄일 수 있다.
    - 페이지 30은 로드, 더하기를 3번 하고 인클리먼트 컴페어 점프를 한다.
        
        - 더하기 3번 당 엘리먼트 3증가 → CPE = 1(이론적) 그런데 어떠한 문제 때문에(아마 레지스터 부족) CPE = 1.33이 나온다.
        
          
        
- 곱셈은 어떻게 최적화 할까
    - imull에 서로 의존성이 있어서 같이 파이프라인하지 못했다.
    - 변수 2개를 사용해서 의존성 제거
    - 홀수번, 짝수번은 자기들끼린 의존성 있지만 서로는 의존성 없다.
    - 결국 CPE = 2(곱하기 2번 당 엘리먼트 2증가)
    - Parallelism이라고 하지만 Parallelism을 높인다고 선형적으로 최적화되지 않는다.