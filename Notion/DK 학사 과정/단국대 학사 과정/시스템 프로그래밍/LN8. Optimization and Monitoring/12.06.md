- 리뷰
    - code mode → combine2
    - 함수 사용 안함 → combine3
    - 지역변수 사용 → combine4
    - for 루프의 조건, 증가에서 자원을 너무 많이 사용하는 문제 해결
        - loop unrolling → combine5
    - loop splitting → combine6
        - 반복할 떄는 dependency가 있지만 x0, x1은 서로 dependency가 없다
p.39
  
## 분기 예측의 성능 분석
- 분기 예측의 패널티는 크다
- 어떻게 하면 분기 예측에 유리하게 코드를 짤까
    
    - -100 ~100에 대해 absval()함수를 적용해보자
    
    ```R
    for(i=-100,; i<101; i++)
    	absval(i);
    
    vs
    
    s = random();
    absval(s);
    ```
    
    - 전자가 분기 예측에 유리하다.
    - regular pattern으로 인풋을 주는 것이 유리한 것이다.
  
## 메모리 계층 성능 분석
- 평균 메모리 접근 시간(AMAT)
    - 프로세스 데이터의 일부는 디램에 일부는 디스크에 존재한다.
        - 모든 프로세스의 데이터가 디램에 올라가있는 것이 아니다.
    - 디램에 있으면 히트
    - 디스크에 있으면 미스
    - AMAT = Phit * Tm + Pmiss * Td
- 히트율
    - Sm / Sd (메모리 크기 / 디스크 크기)
    - 하지만 이렇게 유니폼하게 접근하지 않는다. locality
        - 최근에 접근한 데이터에 집중적으로 접근하는 것
        - 마치 날씨
            - 한 시간전에 비가 내렸으면 지금도 내릴 가능성이 높다.
- 캐시
    - 43페이지 a버전 마지막 포루프를 보자
        - k가 움직이므로 배열의 뒷 인덱스가 증가한다는 것은 메모리 상에서 연속적으로 증가한다는 뜻이다.
        - 하지만 B의 경우 앞인덱스에 k가 들어가서 메모리 상에서 불연속적으로 증가
    - e, f버전 루프가 가장 캐시 친화적인 코드이다.
  
  
## 리눅스 시스템에서 성능 측정하기
- 도구들은 리눅스의 각각 부분을 담당하고있다.
    - 44페이지 참고
- 베이직, 중간, 고급 이렇게 세 가지 카테고리로 나뉜다.
  
- Basic
    
    - ps
        - 윈도우즈의 작업관리자와 비슷한 역할
    - time
        - 어떤 프로세스가 얼마나 실행됐는지 알림
    - ==gettimeofday==
        - 현재 시간 찍어주는 함수
        - 함수 수행 전후에 찍으면 시작 시간과 끝 시간을 알 수 있고 수행시간을 알 수 있다.
    - uptime
        - 시스템이 구동되어 얼마나 시간이 지났는지, 부하가 얼마나 큰지 보여준다.
        - 1, 5, 15분 간격으로 보여준다.
    - TOP
        - 업타입과 PS를 같이 보여준다.
    - vmstat
        - 가상 메모리 통계
    - iostat
    - mpstat
    - pcstat
    - pidstat
    - dstat
        - 모든 스탯을 다 보여준다.
    
      
    
- Intermediate
    - blktrace
        - 블럭 io들이 어떤 순서로 디스크에 접근되는지
    - 이런 툴이 있다만 알아두기
  
- Advanced
    - ==perf_event==
        - 하드웨어적인 이벤트를 뽑아준다.
        - CPU내부 로직이 얼마만큼의 성능을 보이는지 알림
        - CPU가 지원을 해준다
    - ltrace
        - 라이브러리 트레이스
    - ftrace
        - 함수 트레이스
        - 어떤 함수가 얼마나 사용됐는지 알 수 있다.
    - lxc-moniter
        
        - 도커같은 것이다.
        - 컨테이너 상태 알려준다.
        
          
        
- gettimeofday
    - target_job을 수행하기 전 gettimeofday에서 S.S=2, 마이크로초=100
    - 끝나고E.S=4, 마이크로 초= 200
    - 얻은 값으로 특정 계산을 하면 수행시간을 계산할 수 있다.
    - 10000usec(10ms)마다 스케쥴링을 하므로 10000usec이 넘으면 시간이 확 뛰는 것을 볼 수 있다.
  
- 과제