p23~
  
cpu 발전에 따른 기술 이름 나열
특별한 기술은 35페이지에서 설명
  
## Intel CPU History
- 1974에 첫 CPU 출시(8080)
- 1978년에 8086 출시
    - 레지스터 이름이 이 때 처음 정해졌다.
    - Segmentation 도입
        - 메모리 중 일부 공간이 text로 정의
        - cs가 text 끝을 직접 가리킴 → 8086방식
        - real addressing mode
- 80286
    - segmentation 발전시킴
        - 메모리에 text가 있는 것은 동일
        - 중간에 LDT(테이블)을 둬서 cs가 LDT의 엔트리를 가리키고 LDT가 text를 가리킨다.
        - segment descriptor 지원
    - eeflags의 4 privilege level 지원
- 80386
    - 32비트
    - Paging 지원
        - Paging과 Segmentation을 동시 지원
        - 64비트가 된 이후 하드웨어에서는 paging만 사용
- 80486
    - 3개 스테이지(단계)의 파이프라인 첫 도입
        - IF EXE WB
    - 파이프라인을 효과적으로 적용되려면 메모리에서 빠르게 데이터를 가져와야한다
        - 캐시 도입
    - CPU에는 3 단계의 캐시가 있다.
        - L1 L2 L3(LLC)
- Pentium
    - 80586으로 상표등록 하려고 했지만 미국에서 상표 등록에 숫자만사용할 수 없어서 펜티움으로 사용했다.
        - 5에 대응되는 penta를 사용해서 pentium으로 짓고 이후에 펜티움 시리즈로 이어갔다.
    - 파이프라인 단계가 늘었다.
        - 486의 3개의 스테이지에서 5개의 스테이지로 늘어났다.
        - IF DE DF EXE WB
        - 한 스테이지마다 클럭이 발생, 더 많이 스테이지를 나눌 수록 클록을 더 빠르게 할 수 있다.
        - 이후에는 12스테이지, 30스테이지까지 나누기도 했다.
    - 슈퍼스칼라 도입
        - 동시에 두 개의 같은 류의 명령어를 패치해서 수행
        - 정의하기가 어려움
            - broad한 용어
    - L1 캐시가 나누어진다
        - D-캐시, I-캐시
        - 파이프라인을 위해 데이터, 인스트럭션 캐시를 나누었다.
    - MMX technology 도입
        - 멀티 미디어 익스텐션
        - 동영상, 음악을 지원하는 명령어를 지원
        - 멀티미디어 지원이라는 것이 결국 SIMD이다.
            - SIMD는 멀티미디어 지원을 위해 나온 것이다.
            - 화면은 m * n 픽셀로 구성되므로 SIMD가 필요하다.
- P6 family
    - 마이크로 아키텍쳐라는 용어를 공식적으로 사용
        - ISA를 CPU에서 구현하는 방법이 여러개가 있는데 그 구현하는 방법을 마이크로 아키텍쳐로 정의한 것이다.
        - add a, %eax 을 CPU에서 다양하게 구현 가능
            - 인텔은 마이크로 아키텍쳐 방식으로 구현한 것이다.
        - 특징
            - ==무순서 수행(Out-of-order execution)(O3 execution)==
            - ==분기 예측==
            - ==추론 수행==
            - ==데이터 흐름 분석==
            - ==레지스터 리네이밍==
            - 시험 출제: 5가지 암기
            - 모두 파이프라인을 효과적으로 돌리기 위한 특징들이다.
        - Pentium Pro
            - 3-way 슈퍼스칼라
        - Pentium 2
            - Xeon
                - 고성능 인텔 CPU를 제온이라고 부른다.
        - Pentium 3
            - SSE
                - Streaming SIMD Extention
- Pentium 4 Processor Family(7세대)
    - 내부적으로 NetBurst라고 부르는 마이크로 아키텍쳐 사용
        - Deep 파이프라인
            - 20~30개의 파이프라인으로 나누었다.
                - 클럭 스피드 키울 수 있었다.
                - AMD와 클럭 스피드로 싸웠기 때문에 딥 파이프라인을 사용
                    - 클럭을 2000까지 올렸다
                    - 하지만 파이프라인 복잡도가 커지고 발열이 심해서 10기가헤르츠까지는 못 올렸다.
    - 하이퍼 쓰레딩
        - 문맥 교환을 CPU에서 지원
            - CPU 내부에 문맥 교환이 필요없게 문맥을 2개를 갖고 있는다.
    - 듀얼 코어(Pentium D)
    - 64비트 주소공간
    - 가상화 기술
    - 최신 기술을 많이 소개한, 기념비적인 CPU
    - 하지만 시장에서는 실패했다.
        - AMD에게 패배함
            - 파이프라인 효율이 떨어짐
            - 클럭이 너무 높아 파워소모가 늘고 발열이 심했다.
                - 에러 발생 확률이 높아진다는 의미이다.
            - NetBurst 아키텍처를 폐기하고 P6 마이크로 아키텍처를 리엔지니어링 한다.
- Intel Core Processor Family
    - Reengineering based on P6 마이크로아키텍처
        - 파이프라인을 14개로 확 줄임
    - 네이티브 듀얼 코어
        - 클록을 높이기보다 코어수를 늘리는 전략으로 바꿨다.
        - 설계할 때부터 cpu의 일부를 코어를 따로가지고있고 일부는 코어를 공유할 수 있도록 멀티 코어를 염두에 두고 설계했다.
    - intel x86의 거의 마지막 세대(8세대 쯤)
- Intel Core i3/i5/i7 Family
    - 인텔 코어부터 세대를 다시 카운트했다.(지금은 13세대)
    - 네할렘 마이크로 아키텍처
        - 퀵패스 인터커넥트
        - IMC
        - 둘을 합쳐서 NUMA라고 부른다.
        - 이전
            - 컴퓨터는 버스 CPU, MEMORY, IO Device가 있었다.(멀티코어x)
        - 네할렘
            - CPU가 여러개라 각각을 Core라고 부른다.
            - 버스 co들, memory, io device가 있다.
                - 그런데 core 사이에 정보 공유에 문제가 생긴다면?
                - 스케줄링에 문제가 생긴다면?
                - 이전엔 CPU를 어떻게 아끼지 고민했지만 이제부터는 DRAM을 어떻게 아끼지 고민하게됐다.
                    - DRAM에서 병목이 생긴다.
                - 그래서 DRAM을 코어 바로 옆에 붙인다.
                - 그 후 코어를 서로 연결했다. : Quickpath 인터커넥트
                    - 코어 입장에서 자기 바로 옆 메모리를 접근할 때 매우 빠르다.
                    - 다른 코어 옆 메모리 접근엔 느리다.
                    - 이 접근 속도 차이를 NUMA라고 부른다.
                        - Non - Uniform Memory Access
                    - 메모리 컨트롤러가 칩 안에 들어간다.
                        - IMC(Integrated Memory Controller)
        - 다음 아키텍처가 Sandy Bridge, Haswell…
            - Haswell
                - GPU가 내장
                - streaming processor(SP)가 모여있는 구조
            - tick-tock 전략으로 발전
            - 마케팅 이름: 코어 i3, i5, i7
  
  
- 틱톡 전략
    
    - 코어 사이즈 줄이기
    - 한 소켓에 여러 코어를 넣을 수 있게 만들기 위함.
    - 톡 : 새로운 기술 집어넣기
        - 새 마이크로아키텍처 집어넣기
    - 틱: 공정을 효과적으로 줄임
    
      
    
      
    
## Technologies of Intel CPU
- 표는 CPU에서 어떤 명령어들이 얼마나 수행되는지 나타낸다.
    - 많이 사용하는 동작을 최적화해야한다.
    - 놀고 있는 자원을 없도록 해야한다.
        - 파이프라인
        - 슈퍼스칼라
- Pipeline
    - 레이턴시는 늘어나더라도(한 명령어 수행 시간)
    - throughput이 줄어든다(총 명령어 수행 시간)
    - no free lunch
        - 항상 tradeoff이다.
        - 어디선가 좋아지면 어디선간 나빠진다.
    - 파이프라인에 신경써야 하는 것
        - 모든 명령어가 비슷한 수행 시간이어야한다.
            - RISC 사용
            - b = a + b를 어셈블리어로 표현할 때
                - addl a,b
                    - 6 clock 필요
                    - 뒤 다른 명령어들을 밀리게 만들어서 결국 성능 저하
                - movl a,%eax; addl b, %eax; movl %eax, b
                    - 7 clock 필요
                    - 하지만 파이프라인이 수월하게 수행되게 해서 성능 향상
        - 파이프라인 충돌을 줄인다.
            - Data 캐시와 Instruction 캐시를 구분
        - ==Hazard==
            - data hazard
                - 1: addl b, %eax; 2: movl %eax, b
                - 1의 exe하는 동안 2의 data fetch가 불가능하다. (데이터 의존)
                - 그래서 1의 res까지 마무리 될 때 까지 2칸 밀린다.
                - 해결 방법
                    - 무순서 수행(CPU측 방식)
                        - 독립적인 명령어를 가져와서 수행한다.
                    - 레지스터 리네임
                        - 1번 명령어 수행이 끝나면 레지스터에 저장하지 않고 다음 명령어로 바로 가져올 수 있다.
            - control hazard
                - ex
                - if(c==0)
                    - A 수행
                - else
                    - B 수행
                - cmpl c, $0 명령어의 exe까지 끝나야 A, B 중에 뭘 수행할 지 결정할 수 있어서 exe가 끝날 때까지 기다려야한다.
            - 해결법
                - branch prediction 분기 예측
                    - 위로 올라가는 분기가 훨씬 많다(for 루프때문에)
                    - 그래서 분기 예측이 쉽다.
                - Spectre execution 추론 수행
                    
                    - A, B 둘 다 수행한다음 필요한 것이 결정되면 필요한 것만 사용한다.
                    - meltdown (참고, 보안 관련 키워드)
                        - 인텔 CPU 취약성 사용
                        - 추론 수행때문에 둘 다 수행
                        - 이걸 이용해서 인텔 시스템을 녹여버린다.
                        - spectre도 나중에 찾아보기