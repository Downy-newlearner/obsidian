프로세서 관련 시스템 콜  
fork  
exec  
exit  
wait 특정 프로세서 기다림  
getpid 프로세서의 id 가져옴  
fork exec
  
fork p.9
![[Source/Untitled 113.png|Untitled 113.png]]
어떤 프로세서가 만들어지면그걸 관리하기 위해 tesk struct가 만들어진다  
fork를 하면 text공유 ㅡ stack, data는 복사된다.  
  
각 프로세스마다 address space를 따로 가지고있다.(서로 보호가 된다.)(가상 메모리라서 그렇다)  
학생에 비유하자면 어드레스 공간이 일종의 자리이다. 한 자리에 두 명이 앉아있진 않다  
어드레스 공간이 프로세스를 분리시킨다.  
- fork()의 리턴값
    - 자식 프로세스는 리턴값이 0이다
    - 부모 프로세스는 자식 프로세스의 pid를 리턴값으로 가진다.
exec p.13
  
어떤 프로세스가 있을 때 exec은 새로운 프로그램을 로딩하는 것이다.  
![[Source/Untitled 1 74.png|Untitled 1 74.png]]
현재 프로세스의 메모리 이미지(text, data, stack)를 새 바이너리로 대체하는 것이다.  
디스크에 내려가서 가져오고 기존의 메모리를 반납하고 새로운 메모리 이미지를 로딩하여 수행한다.  
fork's syntax  
인자가 없다. 쉽다.  
exec's syntax
1. 바이너리 이름 (수행하고싶은 프로그램의 이름)
2. 인자들이 들어감
3. environment(환경)이 들어간다.  
    결국 프로그램을 수행하는 것이다.  
    쉘에서 ls -l같은 커맨드가 exec으로 수행된다.  
    gcc -o hello.out hello.c 같은 커맨드도 gcc는 바이너리이고 exec으로 수행된다. 이후 인자들은 2번의 argument로 들어간다.  
    요약하면, exec은 3개의 인자가 필요하다.  
    
오늘은 argument와 environment에 대해서 알아본다.
메인 함수는 인자를 하나도 사용하지 않을 수 있다.  
argc, argv[]를 사용할 수도 있다.  
argc는 인자의 개수  
argv는 인자를 받는 인자 벡터이다.  
env를 추가로 사용할수 있다.
path도 대표적인 환경 변수 중 하나이다.
그것이 env 인자로서 전달된다.
env는 스트링의 배열이다.
### Practice 4
for 루프를 돌면서 0부터 argv[]에 무언가가 있으면 for루프 조건은 참, 널스트링이 나오면 false가 된다.
쉘 상에서 명령어쓰고 뒤에 인자를 주면 argv에 전달이 된다.
그 아래가 env, 리눅스에 로그인하면 나도 모르게 이런 환경변수를 사용하고있음을 알 수 있다.
env0 : 헤더파일 경로
env2: 사용중인 쉘
3: 쿠키 정보
4: 컴퓨터의 ip
5: 사용하는 가상 터미널의 번호
7: 유저 이름
8: 터미널의 정보(창의 사이즈 등)
이런 것들이 환경변수이다.
환경변수가 왜 필요한가?
ex:
cat → 파일을 열고 다 출력
more → 파일을 열고 터미널 사이즈를 고려해서 페이지로 분할하고 출력
이 때 터미널의 사이즈는 env를 참고한다.
more은 환경 변수에 접근할 필요가 있다.
이처럼 환경 변수에 접근해야하는 커맨드가 있다.
  
또한 환경변수는 내가 원하는 대로 바꿀 수 있다.
환경 변수를 설정할 수 있는 방법이 있다.
ex
bin/bash 쉘을 사용하고있는데 c쉘로 변경할 수 있다.
그것이 env
  
### Practice 5
메인 함수는 특별해서 끝나면 자동으로 exit(0)한다.
exec에서 전달하거나
wait는 자식 프로세서가 끝나면 돌아오는데 자식이 먼저 수행되면 그냥 종료된다.(함수 동기화)
ex
db성능을 위해 프로세스 2개
1. 하나는 db초기화
2. 하나는 쿼리를 받아서 처리
당연히 db초기화 프로세스가 먼저 실행되어야한다.
그럴 때 wait()를 사용한다.
질문 : Practice5 코드에서 부모 프로세스는 wait(&exit_status); 부분에서 자식 Pid를 받아 리턴해야하는데 만약 부모가 wait()하는 상태에서 자식이 실행되는 것이 아니라, 자식이 먼저 실행되어 끝나버리면 wait(&exit_status);에서 어떻게 자식 pid를 받을 수 있나?
프로세스가 끝나도 os는 프로세스의 상태는 저장하고있다.(좀비)
프로세스가 끝나면 좀비 상태가 된다.
그 때 부모가 wait()로 자식이 좀비 상태임을 알고 pid와 exit_status를 얻어올 수 있다.
  
### ELF p.17
디스크 상에 존재하는 바이너리는 프로세스 구조와 잘 매치되도록 설계되어있다.
그 포멧이 ELF이다.
재배치가능 파일
링킹이 안되면 extern등 외부 참조를 할 수 없다.
그래서 링킹 후 실행 가능 파일로 만들어야 실행이 가능하다.
  
프로세스 만들어지면 아랫쪽부터 text - data- heap - stack
ppt 그림의 .text가 text이다. .rodata도 text이다. (read only data)
data : .data, .bss 둘 다 전역변수. (.data는 초기화된 전역변수 & .bss는 초기화x 전역변수)
heap: ==.symbol ??== , .rel.text, .rel.data ( .rel = relocatable)
ex
extern at z; 언젠가 링킹이되어서 다른 파일이랑 묶여야 사용가능
나중에 재배치가능한 데이터가 다 올라간다(text, data로)
  
실행가능 파일에 .init : 전처리 해야하는 파일들이 들어감
또한 Segment header table 실행할 때 메모리가 어디로 올라가야하는지 알린다.
  
data와 bss로 구분하는 이유
exec할 때 성능을 향상시키기 위함이다.
전역 변수에 초기값이 없으면 그냥 0으로 생각 있으면 읽어와야한다.
다 읽어올 필요가 없게 만드므로 exec 성능이 빨라진다.
bss : block started by symbol의 약자이다.
심볼로 시작되는 블록들
  
### p.18
objdump -h
-h 속성은 세션 정보를 보여준다.
  
### Shell p.19
명령어를 해석하여 처리한다.
  
어떻게 구현되는가
p.19 그림 참고
프롬프트($)에서 명령어 대기
input 후 parsing(워드 단위로 자른다.) 파싱 결과는 토큰이다.
string → 토큰으로 나누고 → 트리 → 맞으면 컴파일 성공
내부 명령어? 외부 명령어? 판단
내부 → 아래로 내려감
외부 → fork
ex
objdump은 외부 명령어이다.
gcc도 외부
외부 명령어는 fork exec으로 처리한다.
cd는 내부 명령어이다.
쉘이 수행하는 환경에 변화를 주는 명령어가 내부 명령어이다.
내부 명령어는 시스템 콜을 불러서 처리한다.
exec이 끝날 때까지 shell은 wait를 하고 있는다.
  
p.19 예시
sh을 fork sh sh → sh ls
cd는 내부 명령어, 쉘 내부에서 처리한다.
$ 이전에 반영된 것을 확인할 수 있다.
  
쉘의 고급 기능
백그라운드 프로세싱(&)
재지정
파이프
쉘 스크립트
  
### 쉘의 Basic Logic p.20
(분석해보기)
  
### p.22 background precessing, redirection, pipe
background process : 쉘과 다른 프로세스를 동시에 실행
fork()를 하고 wait()를 안 하면 된다.
  
### Pipe() example
프로세스간에 정보를 IPC를 통해 주고받는다.(소켓?)
그 중 하나가 pipe이다. fd 2개로 연결되는 파일이다.
프로세스가 있고 pipe(fd)로 호출
파이프는 파일 디스크립터가 2개 (fd[0], fd[1])
fd[0] : 읽기용
fd[1] : 쓰기용
파이프는 일종의 파일이고 2개의 fd로 접근되는 파일 0은 read, 1은 write
그 상태에서 fork를 하면 부모 p와 동일한 자식 p가 생기고 자식 p도 파이프를 공유한다.
블럭이 되면 데이터를 기다린다(디폴트가 block, O_UNBLOKING 참고)
  
자식은 if(fork() == 0)으로 들어가고 write부터 수행 그리고 sleep()
부모는 else로 들어가고 read부터 수행 그리고 wait에서 자식이 다시 꺠어남
자식 exit(0)까지 수행 그리고 부모도 다시 깨어나서 close()까지 수행
  
1. pipe만들기
2. cat 프로세서 만들기
3. wc 프로세서 만들기
4. cat의 표준 출력이 pipe의 표준 입력
5. pipe의 표준 출력이 wc의 표준 입력