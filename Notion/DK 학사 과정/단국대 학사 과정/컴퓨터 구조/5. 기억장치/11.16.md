## 5.5.4 교체 알고리즘
캐시 미스가 나타났을 때 주메모리 데이터를 캐시에 집어넣는 것이다.
현재 사용하는 명령어, 데이터는 다음에 또 사용될 가능성이 높기 때문이다.
캐시 적중률을 극대화할 수 있도록 교체할 블록을 선택하기 위한 알고리즘이 교체 알고리즘이다.
  
1. 최소 최근 사용(LRU) 알고리즘
사용되지 않은 채로 가장 오래 있었던 블록을 교체하는 방식
  
1. FIFO 알고리즘
캐시에 적재된 지 가장 오래된 블록을 교체하는 방식
  
1. 최소 사용 빈도(LFU) 알고리즘
  
  
## 5.5.5 쓰기 정책
캐시에 있는 데이터가 업데이트가 되는 상황이면 주 메모리를 먼저 업데이트하고 그 다음에 캐시 데이터를 업데이트 해야한다.
1. Write-through 정책
    
    모든 쓰기 동작들이 캐시와 주기억장치에 동시에 수행되는 방식
    
    장점
    
    캐시, 주기억장치 동시에 업데이트되므로 블록 내용 동기화가 항상 되어있다.
    
    단점
    
    모든 쓰기 동작이 동시에 수행되므로, 쓰기 시간이 길어진다.
    
      
    
2. Write-back
    
    캐시 먼저 업데이트 하고 주기억장치는 나중에 업데이트한다.
    
    8장에서 추가 설명한다.
    
    장점
    
    주기억장치에 대한 쓰기 동작의 횟수가 최소화 → 쓰기 시간 단축
    
    단점
    
    데이터 불일치 현상이 발생할 수 있다.
    
      
    
    상태 비트를 사용하여 캐시의 데이터가 업데이트 되면 상태 비트를 1로 한다.
    
    블록을 교체할 때 상태 비트가 1인 데이터들은 주기억장치에도 업데이트를 수행한다.
    
      
    
데이터 불일치 문제
캐시 일관성 프로토콜이라는 소프트웨어가 필요하다.
ex: MESI 프로토콜
8장에서 추가 설명
  
여러 캐시에서 x블록을 가져와 갖고있는 상황이라면 Write-through 방식을 사용해서 1번 캐시랑 주 기억장치를 동기화해도 2번 캐시와 1번 캐시, 주기억장치는 동기화가 안 될 수 있다.
MESI 프로토콜 사용
8장에서 설명
  
## 5.5.6 다중 캐시
  
1. 계층적 캐시
    
    L2캐시는 L1캐시의 수퍼 세트다.
    
    수퍼 세트 : 다 포함시키는 세트
    
    L1에 있는 데이터는 L2에도 다 있다.
    
      
    
    어떤 데이터를 찾고있다면 L1에서 먼저 찾고 없으면 L2에서 찾고 없으면 주기억장치에서 찾는다.
    
      
    
    - 2-단계 캐시 시스템의 평균 기억장치 액세스 시간
        
        - Ta = H1 * TL1 + (H2-H1) * TL2 + (1-H2) * Tm
        - 단순한 버전
        
          
        
    - 만약 H2가 L1에서 미스 된 액세스들에 대한 L2의 적중률이라면
        - Ta = H1 * TL1 +(1-H1)H2 * TL2 + {1 - H1 - (1-H1)H2} * Tm
        - L1에서 미스했을 때 확률에 L2에서의 히트율을 곱한다
            - (1-H1) * H2
        - 좀 더 정교한 버전
        - 이걸 더 많이 사용한다.
    
      
    
2. 분리 캐시
    
    캐시를 명령어 캐시와 데이터 캐시로 분리
    
    명령어 인출 유닛과 실행 유닛 간의 캐시 액세스 충돌 제
    
    파이프라인 실행에 도움을 준다.
    
      
    
      
    
## 5.6 DDR SDRAM
기억장치 액세스 및 데이터 전송률 향상 기술 개발
  
## 5.6.1 SDRAM
동기식 DRAM
엑세스 동작들이 시스템 클록에 맞추어(동기화되어) 수행되는 DRAM
  
내부 조직
다수의 뱅크들로 구성된다.
  
ex: 512Mbit SDRAM
4개의 16M * 8bit 뱅크들로 구성
4 * 16Mbyte = 64Mbyte
전체 주소 비트는 26비트
최상위 2 비트는 뱅크 선택에 사용.
가로 세로 형태로 되어있다.
가로 : 16Kbit
세로 : 기억소자 배열
메모리에서 주소를 찾을 때 column address strove, row address strove로 주소의 최종 목적지에 도달할 수 있다.
  
바이트 단위로 데이터버스에 실린다는 뜻은
데이터버스 크기는 요즘 32 또는 64bit이다
32bit이라고 했을 때 4개의 뱅크에서 나오는 데이터를 한 번에 읽을 수 있다.
버스트 모드
한 번의 액세스 동작 때 여러 바이트들을 연속적으로 전송하는 방식
버스트 길이
한 번의 버스트 모드 동안에 전송되는 데이터 바이트들의
![[Source/Untitled 130.png|Untitled 130.png]]
행 선택 → 열 선택 → 데이터 값들을 기억소자에서 감지 증폭기까지 이동(가장 오래 걸림) → 버스로 전송
ex : 3GHz CPU
SDRAM은 동기식이라 clock을 이용한다.
클록은 신호가 0에서 1로 올라가고 1에서 0으로 내려간다.
이 것을 1초에 30억번을 한다. (G는 2의 30승 = 10억대)
클록이 왔다갔다하면서 동시에 수행할 수 있는 작업이 있다.
==RAS신호(24bit 중 13bit), CAS 신호(24bit 중 11bit)==
cas 지연 : 활성화 후 데이터를 읽어오는데 걸리는 지연시간
  
- SDRAM
    - 데이터를 읽을 때 보통 8비트씩 읽는다.
- DDR SDRAM
    - 상승-에지뿐만 아니라 하강-에지에서도 데이터를 전송
    - 즉 하강 에지에서도 버스팅을 한다.
        - p.96에 그림 참고(그림에선 상승 에지만 이용)
- DDR2 SDRAM
    
    - 버스 클록 주파수를 2배로 높여 대역폭 향상
    
      
    
p101 계산해보기
p.102 이런게 있다 정도만 알기
p.105 기억장치 대역폭: 이런게 있다 정도만 알기
  
CAS 지연
큰 변화는 없다.
내용 파악하기
  
5.6.3부터는 빨리 지나갈 예정이고
다음 시간에는 6장을 한다.