## 5.5 캐시 메모리
주 메모리의 데이터를 캐시에 저장하고 캐시에서 데이터를 읽어옴으로써 빠르게 데이터를 가져온다
- 캐시 적중
    - CPU가 원하는 데이터가 캐시에 있는 상태
- 캐시 미스
    - CPU가 원하는 데이터가 캐시에 없는 상태
    - 이 경우에는 주기억장치로부터 데이터를 읽어온다.
- 적중률(hit ratio)
    - 캐시에 적중되는 정도
    - H = 캐시에 적중되는 횟수 / 전체 기억장치 액세스 횟수
- 캐시 미스율
    - 1-H
- 평균 기억장치 액세스 시간
    - 적중률과 캐시 미스율로 계산할 수 있다.
    - Ta = H * Tc + (1-H) * Tm
    - Tc는 캐시 액세스 시간, Tm은 주 기억장치 액세스 시간
  
캐시 적중률은 데이터의 지역성에 따라 달라진다.
  
- 지역성
    - 시간적 지역성
        - 최근에 액세스된 데이터가 가까운 미래에 다시 액세스가 될 가능성 높다.
    - 공간적 지역성
        - 예를 들어 지역변수가 선언되었을 경우 모든 지역변수는 연속된 공간에 저장된다.
        - 따라서 함수 안에서 프로그램을 돌릴 때 연속된 지역 공간에 접근할 가능성이 높다.
        - 또한 루프에서 사용되는 데이터는 연속적인 데이터 공간에 있을 가능성이 높다.
    - 순차적 지역성
        - 분기가 발생하지 않는 한, 명령어들은 기억장치에 저장된 순서대로 인출되어 실행된다.
  
- 캐시 설계에 있어서 공통적인 목표
    - 캐시 적중률 극대화
    - 캐시 액세스 시간의 최소화
        - 가장 많이 사용하는 방법은 associative memory를 이용한다.(세트-연관 사상)
            - 여러 데이터를 동시에 비교하는 HW를 이용해서 검색을 빠르게 수행한다.
    - 캐시 미스에 따른 지연 시간의 최소화
        - 메모리에 접근해야한다는 뜻이므로 지연시간 단축이 쉽진 않다.
        - 다음에 가져오는 데이터를 잘 고려하는 것이 필요
    - 일관성 유지 및 그에 따른 오버헤드 최소화
        
        - 만약 값을 가져와서 업데이트를 안하면 상관 없는데 캐시에 있는 데이터를 업데이트 하면 메인메모리의 데이터도 업데이트를 해줘야한다.(일관성 유지를 해야하기 때문이다.)
        - 언제 업데이트 해야하는지 고려해야한다.
        
          
        
## 5.5.1 캐시 용량
- 용량이 커진다면
    - 적중률이 높아지지만
    - 비용 증가하고
    - 주소 해독 및 정보 인출을 위해 주변 회로가 더 복잡해지고
        - 그래서 액세스 시간이 길어진다.
## 5.5.2 인출 방식
- 인출 방식
    - 요구 인출 방식
        - 필요한 정보만 인출
    - 선인출
        - 필요할 것으로 예측되는 정보도 미리 인출
- 블록
    - 주기억장치를 액세스할 때 함께 인출되는 정보들의 그룹
    - 일반적으로 2~4단어 정도가 최적인 것으로 알려져있다.
  
![[Source/Untitled 129.png|Untitled 129.png]]
- 주기억장치
    - 주기억장치는 2^n개의 단어들로 구성된다.
    - 각 단어는 n비트의 주소에 의해 지정된다.
    - 선인출을 위하여 주기억장치를 K개의 단어들로 이루어진 블록으로 나눌 경우
        - 전체 블록들의 수는 2^n/K개가 된다.
- 캐시
    - 캐시는 m개의 라인들로 구성된다.
    - 각 라인에는 주기억장치 블록과 같은 크기인 K개의 단어들이 저장된다.
        - 즉 캐시의 한 라인에는 주기억장치의 한 블록이 저장된다.
    - 캐시는 주기억장치보다 용량이 적기때문에 캐시의 각 라인에 태그를 두어 그 라인에 어떤 블록이 들어가있는지 알 수 있어야한다.
        - 어떤 주기억장치블록들이 어느 캐시 라인을 공유할 것인지 결정하는 방법이 사상방식이다.(mapping)
## 주기억장치와 캐시의 조직
캐시의 크기는 주기억장치보다 훨씬 작다.
각각의 캐시는 라인번호에 의해 구분할 수 있다.
주기억장치 블록을 하나의 캐시 라인에 적재한다.
주기억장치의 블록은 하나의 캐시라인에 적재할 수 있도록 애초에 구성한다.
블록은 K개 단어로 구성되어있다. (캐시의 한 라인의 크기도 K 단어)
  
- 블록
    - 주기억장치 용량 = 2^n단어, 블록 = k 단어라면
        - 블록의 수 = 2^n/k 개
- 라인
- 태그
  
## 5.5.3 사상 방식
각 주기억장치 블록이 어느 캐시 라인에 적재될 것인지를 결정해주는 방식이다.
캐시 내부 조직을 결정한다.
직접 사상 캐시
![[Source/Untitled 1 84.png|Untitled 1 84.png]]
완전-연관 사상
### 직접 사상
![[Source/Untitled 2 56.png|Untitled 2 56.png]]
- 매우 간단하다.
- 추가적인 HW가 필요하지 않다.
- 대신 느리다.
- 라인을 찾아가는 시간이 좀 걸린다.
- 각 주기억장치의 블록이 지정된 하나의 캐시 라인으로만 적재된다.
  
- 태그 필드
    - 태그 번호(라인에 적재되어있는 블록의 번호)
- 라인 번호
    - 2의 l승만큼 라인을 가질 수 있다.
- 단어 필드
    - 예제 참고
  
캐시의 라인 수는 2의 l승(m)개이기 때문에 블럭 j가 적재될 수 있는 캐시 라인의 번호 i는 mod(모듈러프레션)을 사용해서
i = j mod m 이다.
j: 주 기억장치 블록 번호
m : 캐시 라인의 전체 수
  
라인을 공유하는 주기억장치 블록들
p.53 참고
  
p.54 예제
하나의 블럭 크기가 하나의 라인에 저장된다.
라인은 0~m-1까지 m개 존재한다.
메모리 주소에 있는 데이터가 캐시에 존재하는지 존재하지 않는지 체크를 하기 위해서 검색하는 과정이다.
1. 라인 넘버 체크
2. 캐시에 있는 지정된 라인에 가서 그 라인의 태그 번호를 가져와서 접근하려는 주소의 t 태그와 비교를 한다.(비교기 이용)
3. 똑같은 태그라면 캐시 적중이 발생한다.
    1. 그럼 데이터를 가져올 수 있다.
4. 같은 태그를 가지고있지 않다면 캐시 미스가 발생한다.
    1. 주 기억장치에 가서 데이터를 가져와야한다.
    2. 인출된 블록을 지정된 캐시 라인에 적재하고, 주소의 태그 비트들을 그 라인의 태그 필드에 기록
이 내용은 p.55와 같은 내용이니 참고
  
p.56 예제
주 기억장치는 4바이트 블록이 32개로 구성되어있다.
블록이 4바이트라는 것은 주소로 2비트 필요하다는 뜻이다.
주소의 주소는
4바이트를 사용한다는 것은 주소값이 바이트 사이즈이다.
이것은 맨 앞 비트들이 00 01 10 11 이라는 것이다.
즉 2개의 비트로도 접근할 수 있다는 것이다.
캐시 용량은 32바이트로 지정하고 사용하자.
캐시 라인 크기는 4바이트(왜냐하면 블록 크기가 4바이트이다.)
전체 캐시 라인의 수는 8개이다
3개의 비트만 있으면 8개의 주소를 짤 수 있다.
7비트 주소(캐시에 접근하는 수단)
태그 비트 2개
라인 주소 3개
==단어 주소 2개==
==word가 아니고 말 그대로 단어를 의미하는 것인가?==
각 기억장치 블록이 공유하게 될 캐시 라인 번호
i = j ==mod== 8
p. 58 참고하면 더 쉽게 이해할 수 있다.
캐시에 있는지 확인하려면(p.58)
1. 라인 번호 확인
2. 태그 번호 체크
==그럼 각 라인번호에 저장될 데이터는(캐시에서) 4개의 태그 중 하나인가?==
==캐시의 000라인번호에는==
==태그 00의 ‘abcd’ 또는==
==태그 01의 ‘drop’ 또는==
==태그 10의 ‘down’… 인가?==
→ 맞다
00 000 00 의 ‘abcd’에서 마지막 00은 단어의 주소인데 이것은 a를 가리킨다
b c d 순서대로 01 10 11이다.
  
11 101 11을 가져온다는 것은 일단 ‘tech’전체를 캐시로 가져오고 단어 주소 11은 ‘tech’ 중 h이므로 h를 가져온다.
  
장점
하드웨어가 간단하고, 구현 비용이 적게 든다
단점
p60 참고
swap-out
캐시에서 빠져나와 주 메모리로 들어감을 의미한다.
캐시에서 업데이트된다면 주메모리에서도 업데이트가 되어야하는데
바로 업데이트 될 때도 있고 swap-out 될 때 업데이트 될 수도 있다.
나중에 추가 설명
### 완전-연관 사상
![[Source/Untitled 3 46.png|Untitled 3 46.png]]
- 비용이 많이 들어서 많이 사용하지 않는다.
- 주기억장치 블록이 캐시의 어떤 라인으로든 적재 가능(태그만 존재한다.)
- 단어 필드는 블록의 크기와 같다.
  
p.62 예제
완전 연관 사상을 사용하므로 associative memory(비교를 동시에 한다.) 사용.
태그가 어디에 저장되어있는지를 바로 알고있어야한다.
원하는 태그가 캐시에 있는지 체크를 위해서 비교기를 이용하여 비교하는데 동시에 비교한다.
라인이 태그에서 다 나와서 비교기에서 태그와 동시에 비교한다.
이것이 associative memory이다.
비교기 HW가 비싸다.
캐시 라인의 숫자가 많을 수록 더 비싸진다.
비교기에서 캐시가 적중이 되면 그 라인으로 가고 미스나면 주 기억장치로 가서 데이터 인출 후 캐시에 저장
  
장점
새로운 블록이 캐시로 적재될 때 라인의 선택이 매우 자유롭다.
위에서부터 차근차근 적재
p.65를 보면 차근차근 적재함을 볼 수 있다.
지역성이 높다면, 적중률이 매우 높아진다.
단점
캐시 라인들의 태그를 병렬로 검사해서(동시에 검사해서) 가격이 높은 연관 기억장치(associative memory)를 사용해야한다.
  
### 세트-연관 사상
![[Source/Untitled 4 33.png|Untitled 4 33.png]]
- 직접 사상과 완전-연관 사상의 조합
- 주기억장치 블록 그룹이 하나의 캐시 세트를 공유하며
- 각 세트안에 k개의 라인이 있으면 k-way세트-연관 사상이라고 부른다
- 캐시 세트의 번호를 알아야한다.
    - i = j mod v
        - i : 캐시 세트의 번호
        - j : 주기억장치 블록 번호
        - v : 캐시 세트들의 수
- 직접엔 라인필드가 있었지만 세트-연관엔 세트 필드가 있다.
- 2way-세트 연관이라는 것은 각 세트마다 2개의 라인이 있다는 것을 의미한다.
    - 캐시는 32바이트로 구성되어있다고 예시를 들었으므로
        - 라인 8개를 가질 수 있다.
    - 각 세트마다 2개의 라인을 가지고있으니 4개의 세트가 만들어진다.
- 주소의 태그 필드 내용과 그 세트내의 태그들을 비교한다.
    - 캐시 적중과 미스를 판단한다.
    - 세트 주소로 먼저 찾아가고 그 세트 안에 태그들을 비교기에서 태그 주소와 비교한다.
# 시험 : 예제 꼭 풀어보기
  
p.77 꼭 풀어보